/*
 * generated by Xtext 2.25.0
 */
package org.eclipse.fordiac.ide.structuredtextcore.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class STCoreGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class CodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.Code");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsSTStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//Code:
		//    statements+=STStatement*;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_0() { return cStatementsSTStatementParserRuleCall_0; }
	}
	public class VarDeclarationBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.VarDeclarationBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarDeclarationBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVARKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConstantAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cConstantCONSTANTKeyword_2_0 = (Keyword)cConstantAssignment_2.eContents().get(0);
		private final Assignment cVarDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarDeclarationsVarDeclarationParserRuleCall_3_0 = (RuleCall)cVarDeclarationsAssignment_3.eContents().get(0);
		private final Keyword cEND_VARKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//VarDeclarationBlock returns VarDeclarationBlock:
		//    {VarDeclarationBlock} 'VAR' (constant?='CONSTANT')?
		//    varDeclarations+=VarDeclaration*
		//    'END_VAR';
		@Override public ParserRule getRule() { return rule; }
		
		//{VarDeclarationBlock} 'VAR' (constant?='CONSTANT')?
		//varDeclarations+=VarDeclaration*
		//'END_VAR'
		public Group getGroup() { return cGroup; }
		
		//{VarDeclarationBlock}
		public Action getVarDeclarationBlockAction_0() { return cVarDeclarationBlockAction_0; }
		
		//'VAR'
		public Keyword getVARKeyword_1() { return cVARKeyword_1; }
		
		//(constant?='CONSTANT')?
		public Assignment getConstantAssignment_2() { return cConstantAssignment_2; }
		
		//'CONSTANT'
		public Keyword getConstantCONSTANTKeyword_2_0() { return cConstantCONSTANTKeyword_2_0; }
		
		//varDeclarations+=VarDeclaration*
		public Assignment getVarDeclarationsAssignment_3() { return cVarDeclarationsAssignment_3; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationsVarDeclarationParserRuleCall_3_0() { return cVarDeclarationsVarDeclarationParserRuleCall_3_0; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_4() { return cEND_VARKeyword_4; }
	}
	public class VarTempDeclarationBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.VarTempDeclarationBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarDeclarationBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVAR_TEMPKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConstantAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cConstantCONSTANTKeyword_2_0 = (Keyword)cConstantAssignment_2.eContents().get(0);
		private final Assignment cVarDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarDeclarationsVarDeclarationParserRuleCall_3_0 = (RuleCall)cVarDeclarationsAssignment_3.eContents().get(0);
		private final Keyword cEND_VARKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//VarTempDeclarationBlock returns VarDeclarationBlock:
		//    {VarDeclarationBlock} 'VAR_TEMP' (constant?='CONSTANT')?
		//    varDeclarations+=VarDeclaration*
		//    'END_VAR';
		@Override public ParserRule getRule() { return rule; }
		
		//{VarDeclarationBlock} 'VAR_TEMP' (constant?='CONSTANT')?
		//varDeclarations+=VarDeclaration*
		//'END_VAR'
		public Group getGroup() { return cGroup; }
		
		//{VarDeclarationBlock}
		public Action getVarDeclarationBlockAction_0() { return cVarDeclarationBlockAction_0; }
		
		//'VAR_TEMP'
		public Keyword getVAR_TEMPKeyword_1() { return cVAR_TEMPKeyword_1; }
		
		//(constant?='CONSTANT')?
		public Assignment getConstantAssignment_2() { return cConstantAssignment_2; }
		
		//'CONSTANT'
		public Keyword getConstantCONSTANTKeyword_2_0() { return cConstantCONSTANTKeyword_2_0; }
		
		//varDeclarations+=VarDeclaration*
		public Assignment getVarDeclarationsAssignment_3() { return cVarDeclarationsAssignment_3; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationsVarDeclarationParserRuleCall_3_0() { return cVarDeclarationsVarDeclarationParserRuleCall_3_0; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_4() { return cEND_VARKeyword_4; }
	}
	public class VarInputDeclarationBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.VarInputDeclarationBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarDeclarationBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVAR_INPUTKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConstantAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cConstantCONSTANTKeyword_2_0 = (Keyword)cConstantAssignment_2.eContents().get(0);
		private final Assignment cVarDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarDeclarationsVarDeclarationParserRuleCall_3_0 = (RuleCall)cVarDeclarationsAssignment_3.eContents().get(0);
		private final Keyword cEND_VARKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//VarInputDeclarationBlock returns VarDeclarationBlock:
		//    {VarDeclarationBlock} 'VAR_INPUT' (constant?='CONSTANT')?
		//    varDeclarations+=VarDeclaration*
		//    'END_VAR';
		@Override public ParserRule getRule() { return rule; }
		
		//{VarDeclarationBlock} 'VAR_INPUT' (constant?='CONSTANT')?
		//varDeclarations+=VarDeclaration*
		//'END_VAR'
		public Group getGroup() { return cGroup; }
		
		//{VarDeclarationBlock}
		public Action getVarDeclarationBlockAction_0() { return cVarDeclarationBlockAction_0; }
		
		//'VAR_INPUT'
		public Keyword getVAR_INPUTKeyword_1() { return cVAR_INPUTKeyword_1; }
		
		//(constant?='CONSTANT')?
		public Assignment getConstantAssignment_2() { return cConstantAssignment_2; }
		
		//'CONSTANT'
		public Keyword getConstantCONSTANTKeyword_2_0() { return cConstantCONSTANTKeyword_2_0; }
		
		//varDeclarations+=VarDeclaration*
		public Assignment getVarDeclarationsAssignment_3() { return cVarDeclarationsAssignment_3; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationsVarDeclarationParserRuleCall_3_0() { return cVarDeclarationsVarDeclarationParserRuleCall_3_0; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_4() { return cEND_VARKeyword_4; }
	}
	public class VarOutputDeclarationBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.VarOutputDeclarationBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarDeclarationBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVAR_OUTPUTKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConstantAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cConstantCONSTANTKeyword_2_0 = (Keyword)cConstantAssignment_2.eContents().get(0);
		private final Assignment cVarDeclarationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarDeclarationsVarDeclarationParserRuleCall_3_0 = (RuleCall)cVarDeclarationsAssignment_3.eContents().get(0);
		private final Keyword cEND_VARKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//VarOutputDeclarationBlock returns VarDeclarationBlock:
		//    {VarDeclarationBlock} 'VAR_OUTPUT' (constant?='CONSTANT')?
		//    varDeclarations+=VarDeclaration*
		//    'END_VAR';
		@Override public ParserRule getRule() { return rule; }
		
		//{VarDeclarationBlock} 'VAR_OUTPUT' (constant?='CONSTANT')?
		//varDeclarations+=VarDeclaration*
		//'END_VAR'
		public Group getGroup() { return cGroup; }
		
		//{VarDeclarationBlock}
		public Action getVarDeclarationBlockAction_0() { return cVarDeclarationBlockAction_0; }
		
		//'VAR_OUTPUT'
		public Keyword getVAR_OUTPUTKeyword_1() { return cVAR_OUTPUTKeyword_1; }
		
		//(constant?='CONSTANT')?
		public Assignment getConstantAssignment_2() { return cConstantAssignment_2; }
		
		//'CONSTANT'
		public Keyword getConstantCONSTANTKeyword_2_0() { return cConstantCONSTANTKeyword_2_0; }
		
		//varDeclarations+=VarDeclaration*
		public Assignment getVarDeclarationsAssignment_3() { return cVarDeclarationsAssignment_3; }
		
		//VarDeclaration
		public RuleCall getVarDeclarationsVarDeclarationParserRuleCall_3_0() { return cVarDeclarationsVarDeclarationParserRuleCall_3_0; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_4() { return cEND_VARKeyword_4; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSTVarDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cATKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLocatedAtAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cLocatedAtINamedElementCrossReference_2_1_0 = (CrossReference)cLocatedAtAssignment_2_1.eContents().get(0);
		private final RuleCall cLocatedAtINamedElementIDTerminalRuleCall_2_1_0_1 = (RuleCall)cLocatedAtINamedElementCrossReference_2_1_0.eContents().get(1);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cArrayAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cArrayARRAYKeyword_4_0_0 = (Keyword)cArrayAssignment_4_0.eContents().get(0);
		private final Alternatives cAlternatives_4_1 = (Alternatives)cGroup_4.eContents().get(1);
		private final Group cGroup_4_1_0 = (Group)cAlternatives_4_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_4_1_0_0 = (Keyword)cGroup_4_1_0.eContents().get(0);
		private final Assignment cRangesAssignment_4_1_0_1 = (Assignment)cGroup_4_1_0.eContents().get(1);
		private final RuleCall cRangesSTExpressionParserRuleCall_4_1_0_1_0 = (RuleCall)cRangesAssignment_4_1_0_1.eContents().get(0);
		private final Group cGroup_4_1_0_2 = (Group)cGroup_4_1_0.eContents().get(2);
		private final Keyword cCommaKeyword_4_1_0_2_0 = (Keyword)cGroup_4_1_0_2.eContents().get(0);
		private final Assignment cRangesAssignment_4_1_0_2_1 = (Assignment)cGroup_4_1_0_2.eContents().get(1);
		private final RuleCall cRangesSTExpressionParserRuleCall_4_1_0_2_1_0 = (RuleCall)cRangesAssignment_4_1_0_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4_1_0_3 = (Keyword)cGroup_4_1_0.eContents().get(3);
		private final Group cGroup_4_1_1 = (Group)cAlternatives_4_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_4_1_1_0 = (Keyword)cGroup_4_1_1.eContents().get(0);
		private final Assignment cCountAssignment_4_1_1_1 = (Assignment)cGroup_4_1_1.eContents().get(1);
		private final Keyword cCountAsteriskKeyword_4_1_1_1_0 = (Keyword)cCountAssignment_4_1_1_1.eContents().get(0);
		private final Group cGroup_4_1_1_2 = (Group)cGroup_4_1_1.eContents().get(2);
		private final Keyword cCommaKeyword_4_1_1_2_0 = (Keyword)cGroup_4_1_1_2.eContents().get(0);
		private final Assignment cCountAssignment_4_1_1_2_1 = (Assignment)cGroup_4_1_1_2.eContents().get(1);
		private final Keyword cCountAsteriskKeyword_4_1_1_2_1_0 = (Keyword)cCountAssignment_4_1_1_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4_1_1_3 = (Keyword)cGroup_4_1_1.eContents().get(3);
		private final Keyword cOFKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Assignment cTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cTypeLibraryElementCrossReference_5_0 = (CrossReference)cTypeAssignment_5.eContents().get(0);
		private final RuleCall cTypeLibraryElementIDTerminalRuleCall_5_0_1 = (RuleCall)cTypeLibraryElementCrossReference_5_0.eContents().get(1);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cLeftSquareBracketKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cMaxLengthAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cMaxLengthSTExpressionParserRuleCall_6_1_0 = (RuleCall)cMaxLengthAssignment_6_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cColonEqualsSignKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cDefaultValueAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cDefaultValueInitializerExpressionParserRuleCall_7_1_0 = (RuleCall)cDefaultValueAssignment_7_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//VarDeclaration returns libraryElement::INamedElement:
		//    {STVarDeclaration}
		//    name=ID ('AT' locatedAt=[libraryElement::INamedElement])? ':' (array?='ARRAY' (('[' ranges+=(STExpression) (','
		//    ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')? (type=[libraryElement::LibraryElement]) ('[' maxLength=STExpression ']')? (':='
		//    defaultValue=InitializerExpression)? ';';
		@Override public ParserRule getRule() { return rule; }
		
		//{STVarDeclaration}
		//name=ID ('AT' locatedAt=[libraryElement::INamedElement])? ':' (array?='ARRAY' (('[' ranges+=(STExpression) (','
		//ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')? (type=[libraryElement::LibraryElement]) ('[' maxLength=STExpression ']')? (':='
		//defaultValue=InitializerExpression)? ';'
		public Group getGroup() { return cGroup; }
		
		//{STVarDeclaration}
		public Action getSTVarDeclarationAction_0() { return cSTVarDeclarationAction_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('AT' locatedAt=[libraryElement::INamedElement])?
		public Group getGroup_2() { return cGroup_2; }
		
		//'AT'
		public Keyword getATKeyword_2_0() { return cATKeyword_2_0; }
		
		//locatedAt=[libraryElement::INamedElement]
		public Assignment getLocatedAtAssignment_2_1() { return cLocatedAtAssignment_2_1; }
		
		//[libraryElement::INamedElement]
		public CrossReference getLocatedAtINamedElementCrossReference_2_1_0() { return cLocatedAtINamedElementCrossReference_2_1_0; }
		
		//ID
		public RuleCall getLocatedAtINamedElementIDTerminalRuleCall_2_1_0_1() { return cLocatedAtINamedElementIDTerminalRuleCall_2_1_0_1; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//(array?='ARRAY' (('[' ranges+=(STExpression) (','
		//   ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')?
		public Group getGroup_4() { return cGroup_4; }
		
		//array?='ARRAY'
		public Assignment getArrayAssignment_4_0() { return cArrayAssignment_4_0; }
		
		//'ARRAY'
		public Keyword getArrayARRAYKeyword_4_0_0() { return cArrayARRAYKeyword_4_0_0; }
		
		//(('[' ranges+=(STExpression) (','
		//   ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']'))
		public Alternatives getAlternatives_4_1() { return cAlternatives_4_1; }
		
		//('[' ranges+=(STExpression) (','
		//    ranges+=STExpression)* ']')
		public Group getGroup_4_1_0() { return cGroup_4_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4_1_0_0() { return cLeftSquareBracketKeyword_4_1_0_0; }
		
		//ranges+=(STExpression)
		public Assignment getRangesAssignment_4_1_0_1() { return cRangesAssignment_4_1_0_1; }
		
		//(STExpression)
		public RuleCall getRangesSTExpressionParserRuleCall_4_1_0_1_0() { return cRangesSTExpressionParserRuleCall_4_1_0_1_0; }
		
		//(','
		//   ranges+=STExpression)*
		public Group getGroup_4_1_0_2() { return cGroup_4_1_0_2; }
		
		//','
		public Keyword getCommaKeyword_4_1_0_2_0() { return cCommaKeyword_4_1_0_2_0; }
		
		//ranges+=STExpression
		public Assignment getRangesAssignment_4_1_0_2_1() { return cRangesAssignment_4_1_0_2_1; }
		
		//STExpression
		public RuleCall getRangesSTExpressionParserRuleCall_4_1_0_2_1_0() { return cRangesSTExpressionParserRuleCall_4_1_0_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4_1_0_3() { return cRightSquareBracketKeyword_4_1_0_3; }
		
		//('[' count+='*' (',' count+='*')* ']')
		public Group getGroup_4_1_1() { return cGroup_4_1_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4_1_1_0() { return cLeftSquareBracketKeyword_4_1_1_0; }
		
		//count+='*'
		public Assignment getCountAssignment_4_1_1_1() { return cCountAssignment_4_1_1_1; }
		
		//'*'
		public Keyword getCountAsteriskKeyword_4_1_1_1_0() { return cCountAsteriskKeyword_4_1_1_1_0; }
		
		//(',' count+='*')*
		public Group getGroup_4_1_1_2() { return cGroup_4_1_1_2; }
		
		//','
		public Keyword getCommaKeyword_4_1_1_2_0() { return cCommaKeyword_4_1_1_2_0; }
		
		//count+='*'
		public Assignment getCountAssignment_4_1_1_2_1() { return cCountAssignment_4_1_1_2_1; }
		
		//'*'
		public Keyword getCountAsteriskKeyword_4_1_1_2_1_0() { return cCountAsteriskKeyword_4_1_1_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4_1_1_3() { return cRightSquareBracketKeyword_4_1_1_3; }
		
		//'OF'
		public Keyword getOFKeyword_4_2() { return cOFKeyword_4_2; }
		
		//(type=[libraryElement::LibraryElement])
		public Assignment getTypeAssignment_5() { return cTypeAssignment_5; }
		
		//[libraryElement::LibraryElement]
		public CrossReference getTypeLibraryElementCrossReference_5_0() { return cTypeLibraryElementCrossReference_5_0; }
		
		//ID
		public RuleCall getTypeLibraryElementIDTerminalRuleCall_5_0_1() { return cTypeLibraryElementIDTerminalRuleCall_5_0_1; }
		
		//('[' maxLength=STExpression ']')?
		public Group getGroup_6() { return cGroup_6; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_6_0() { return cLeftSquareBracketKeyword_6_0; }
		
		//maxLength=STExpression
		public Assignment getMaxLengthAssignment_6_1() { return cMaxLengthAssignment_6_1; }
		
		//STExpression
		public RuleCall getMaxLengthSTExpressionParserRuleCall_6_1_0() { return cMaxLengthSTExpressionParserRuleCall_6_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_6_2() { return cRightSquareBracketKeyword_6_2; }
		
		//(':='
		//   defaultValue=InitializerExpression)?
		public Group getGroup_7() { return cGroup_7; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_7_0() { return cColonEqualsSignKeyword_7_0; }
		
		//defaultValue=InitializerExpression
		public Assignment getDefaultValueAssignment_7_1() { return cDefaultValueAssignment_7_1; }
		
		//InitializerExpression
		public RuleCall getDefaultValueInitializerExpressionParserRuleCall_7_1_0() { return cDefaultValueInitializerExpressionParserRuleCall_7_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}
	public class InitializerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.InitializerExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArrayInitializerExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//InitializerExpression:
		//    STExpression | ArrayInitializerExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//STExpression | ArrayInitializerExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STExpression
		public RuleCall getSTExpressionParserRuleCall_0() { return cSTExpressionParserRuleCall_0; }
		
		//ArrayInitializerExpression
		public RuleCall getArrayInitializerExpressionParserRuleCall_1() { return cArrayInitializerExpressionParserRuleCall_1; }
	}
	public class ArrayInitializerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.ArrayInitializerExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValuesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValuesArrayInitElementParserRuleCall_1_0 = (RuleCall)cValuesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cValuesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValuesArrayInitElementParserRuleCall_2_1_0 = (RuleCall)cValuesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ArrayInitializerExpression:
		//    '[' values+=ArrayInitElement (',' values+=ArrayInitElement)* ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' values+=ArrayInitElement (',' values+=ArrayInitElement)* ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//values+=ArrayInitElement
		public Assignment getValuesAssignment_1() { return cValuesAssignment_1; }
		
		//ArrayInitElement
		public RuleCall getValuesArrayInitElementParserRuleCall_1_0() { return cValuesArrayInitElementParserRuleCall_1_0; }
		
		//(',' values+=ArrayInitElement)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//values+=ArrayInitElement
		public Assignment getValuesAssignment_2_1() { return cValuesAssignment_2_1; }
		
		//ArrayInitElement
		public RuleCall getValuesArrayInitElementParserRuleCall_2_1_0() { return cValuesArrayInitElementParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class ArrayInitElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.ArrayInitElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIndexOrInitExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIndexOrInitExpressionSTExpressionParserRuleCall_0_0 = (RuleCall)cIndexOrInitExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cInitExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cInitExpressionSTExpressionParserRuleCall_1_1_0 = (RuleCall)cInitExpressionAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//ArrayInitElement:
		//    indexOrInitExpression=STExpression ('(' initExpression=STExpression ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//indexOrInitExpression=STExpression ('(' initExpression=STExpression ')')?
		public Group getGroup() { return cGroup; }
		
		//indexOrInitExpression=STExpression
		public Assignment getIndexOrInitExpressionAssignment_0() { return cIndexOrInitExpressionAssignment_0; }
		
		//STExpression
		public RuleCall getIndexOrInitExpressionSTExpressionParserRuleCall_0_0() { return cIndexOrInitExpressionSTExpressionParserRuleCall_0_0; }
		
		//('(' initExpression=STExpression ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//initExpression=STExpression
		public Assignment getInitExpressionAssignment_1_1() { return cInitExpressionAssignment_1_1; }
		
		//STExpression
		public RuleCall getInitExpressionSTExpressionParserRuleCall_1_1_0() { return cInitExpressionSTExpressionParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class STStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final RuleCall cSTIfStatementParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0);
		private final RuleCall cSTCaseStatementParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cSTForStatementParserRuleCall_0_0_2 = (RuleCall)cAlternatives_0_0.eContents().get(2);
		private final RuleCall cSTWhileStatementParserRuleCall_0_0_3 = (RuleCall)cAlternatives_0_0.eContents().get(3);
		private final RuleCall cSTRepeatStatementParserRuleCall_0_0_4 = (RuleCall)cAlternatives_0_0.eContents().get(4);
		private final RuleCall cSTAssignmentStatementParserRuleCall_0_0_5 = (RuleCall)cAlternatives_0_0.eContents().get(5);
		private final Group cGroup_0_0_6 = (Group)cAlternatives_0_0.eContents().get(6);
		private final Action cSTReturnAction_0_0_6_0 = (Action)cGroup_0_0_6.eContents().get(0);
		private final Keyword cRETURNKeyword_0_0_6_1 = (Keyword)cGroup_0_0_6.eContents().get(1);
		private final Group cGroup_0_0_7 = (Group)cAlternatives_0_0.eContents().get(7);
		private final Action cSTContinueAction_0_0_7_0 = (Action)cGroup_0_0_7.eContents().get(0);
		private final Keyword cCONTINUEKeyword_0_0_7_1 = (Keyword)cGroup_0_0_7.eContents().get(1);
		private final Group cGroup_0_0_8 = (Group)cAlternatives_0_0.eContents().get(8);
		private final Action cSTExitAction_0_0_8_0 = (Action)cGroup_0_0_8.eContents().get(0);
		private final Keyword cEXITKeyword_0_0_8_1 = (Keyword)cGroup_0_0_8.eContents().get(1);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cSTNopAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//STStatement:
		//    (STIfStatement |
		//    STCaseStatement |
		//    STForStatement |
		//    STWhileStatement |
		//    STRepeatStatement |
		//    STAssignmentStatement |
		//    {STReturn} 'RETURN' |
		//    {STContinue} 'CONTINUE' |
		//    {STExit} 'EXIT') ';' |
		//    {STNop} ';';
		@Override public ParserRule getRule() { return rule; }
		
		//(STIfStatement |
		//STCaseStatement |
		//STForStatement |
		//STWhileStatement |
		//STRepeatStatement |
		//STAssignmentStatement |
		//{STReturn} 'RETURN' |
		//{STContinue} 'CONTINUE' |
		//{STExit} 'EXIT') ';' |
		//{STNop} ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(STIfStatement |
		//STCaseStatement |
		//STForStatement |
		//STWhileStatement |
		//STRepeatStatement |
		//STAssignmentStatement |
		//{STReturn} 'RETURN' |
		//{STContinue} 'CONTINUE' |
		//{STExit} 'EXIT') ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//(STIfStatement |
		//STCaseStatement |
		//STForStatement |
		//STWhileStatement |
		//STRepeatStatement |
		//STAssignmentStatement |
		//{STReturn} 'RETURN' |
		//{STContinue} 'CONTINUE' |
		//{STExit} 'EXIT')
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }
		
		//STIfStatement
		public RuleCall getSTIfStatementParserRuleCall_0_0_0() { return cSTIfStatementParserRuleCall_0_0_0; }
		
		//STCaseStatement
		public RuleCall getSTCaseStatementParserRuleCall_0_0_1() { return cSTCaseStatementParserRuleCall_0_0_1; }
		
		//STForStatement
		public RuleCall getSTForStatementParserRuleCall_0_0_2() { return cSTForStatementParserRuleCall_0_0_2; }
		
		//STWhileStatement
		public RuleCall getSTWhileStatementParserRuleCall_0_0_3() { return cSTWhileStatementParserRuleCall_0_0_3; }
		
		//STRepeatStatement
		public RuleCall getSTRepeatStatementParserRuleCall_0_0_4() { return cSTRepeatStatementParserRuleCall_0_0_4; }
		
		//STAssignmentStatement
		public RuleCall getSTAssignmentStatementParserRuleCall_0_0_5() { return cSTAssignmentStatementParserRuleCall_0_0_5; }
		
		//{STReturn} 'RETURN'
		public Group getGroup_0_0_6() { return cGroup_0_0_6; }
		
		//{STReturn}
		public Action getSTReturnAction_0_0_6_0() { return cSTReturnAction_0_0_6_0; }
		
		//'RETURN'
		public Keyword getRETURNKeyword_0_0_6_1() { return cRETURNKeyword_0_0_6_1; }
		
		//{STContinue} 'CONTINUE'
		public Group getGroup_0_0_7() { return cGroup_0_0_7; }
		
		//{STContinue}
		public Action getSTContinueAction_0_0_7_0() { return cSTContinueAction_0_0_7_0; }
		
		//'CONTINUE'
		public Keyword getCONTINUEKeyword_0_0_7_1() { return cCONTINUEKeyword_0_0_7_1; }
		
		//{STExit} 'EXIT'
		public Group getGroup_0_0_8() { return cGroup_0_0_8; }
		
		//{STExit}
		public Action getSTExitAction_0_0_8_0() { return cSTExitAction_0_0_8_0; }
		
		//'EXIT'
		public Keyword getEXITKeyword_0_0_8_1() { return cEXITKeyword_0_0_8_1; }
		
		//';'
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }
		
		//{STNop} ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//{STNop}
		public Action getSTNopAction_1_0() { return cSTNopAction_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }
	}
	public class STAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftSTAccessExpressionParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightSTExpressionParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//STAssignmentStatement:
		//    left=STAccessExpression ':=' right=STExpression
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//left=STAccessExpression ':=' right=STExpression
		public Group getGroup() { return cGroup; }
		
		//left=STAccessExpression
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//STAccessExpression
		public RuleCall getLeftSTAccessExpressionParserRuleCall_0_0() { return cLeftSTAccessExpressionParserRuleCall_0_0; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }
		
		//right=STExpression
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//STExpression
		public RuleCall getRightSTExpressionParserRuleCall_2_0() { return cRightSTExpressionParserRuleCall_2_0; }
	}
	public class STIfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STIfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionSTExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cTHENKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsSTStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Assignment cElseifsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseifsSTElseIfPartParserRuleCall_4_0 = (RuleCall)cElseifsAssignment_4.eContents().get(0);
		private final Assignment cElseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseSTElsePartParserRuleCall_5_0 = (RuleCall)cElseAssignment_5.eContents().get(0);
		private final Keyword cEND_IFKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//STIfStatement:
		//    'IF' condition=STExpression 'THEN' statements+=STStatement* elseifs+=(STElseIfPart)* (else=STElsePart)? 'END_IF';
		@Override public ParserRule getRule() { return rule; }
		
		//'IF' condition=STExpression 'THEN' statements+=STStatement* elseifs+=(STElseIfPart)* (else=STElsePart)? 'END_IF'
		public Group getGroup() { return cGroup; }
		
		//'IF'
		public Keyword getIFKeyword_0() { return cIFKeyword_0; }
		
		//condition=STExpression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//STExpression
		public RuleCall getConditionSTExpressionParserRuleCall_1_0() { return cConditionSTExpressionParserRuleCall_1_0; }
		
		//'THEN'
		public Keyword getTHENKeyword_2() { return cTHENKeyword_2; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_3_0() { return cStatementsSTStatementParserRuleCall_3_0; }
		
		//elseifs+=(STElseIfPart)*
		public Assignment getElseifsAssignment_4() { return cElseifsAssignment_4; }
		
		//(STElseIfPart)
		public RuleCall getElseifsSTElseIfPartParserRuleCall_4_0() { return cElseifsSTElseIfPartParserRuleCall_4_0; }
		
		//(else=STElsePart)?
		public Assignment getElseAssignment_5() { return cElseAssignment_5; }
		
		//STElsePart
		public RuleCall getElseSTElsePartParserRuleCall_5_0() { return cElseSTElsePartParserRuleCall_5_0; }
		
		//'END_IF'
		public Keyword getEND_IFKeyword_6() { return cEND_IFKeyword_6; }
	}
	public class STElseIfPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STElseIfPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cELSIFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionSTExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cTHENKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsSTStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		
		//STElseIfPart:
		//    'ELSIF' condition=STExpression 'THEN' statements+=STStatement*;
		@Override public ParserRule getRule() { return rule; }
		
		//'ELSIF' condition=STExpression 'THEN' statements+=STStatement*
		public Group getGroup() { return cGroup; }
		
		//'ELSIF'
		public Keyword getELSIFKeyword_0() { return cELSIFKeyword_0; }
		
		//condition=STExpression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//STExpression
		public RuleCall getConditionSTExpressionParserRuleCall_1_0() { return cConditionSTExpressionParserRuleCall_1_0; }
		
		//'THEN'
		public Keyword getTHENKeyword_2() { return cTHENKeyword_2; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_3_0() { return cStatementsSTStatementParserRuleCall_3_0; }
	}
	public class STCaseStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STCaseStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCASEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSelectorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSelectorSTExpressionParserRuleCall_1_0 = (RuleCall)cSelectorAssignment_1.eContents().get(0);
		private final Keyword cOFKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCasesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasesSTCaseCasesParserRuleCall_3_0 = (RuleCall)cCasesAssignment_3.eContents().get(0);
		private final Assignment cElseAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseSTElsePartParserRuleCall_4_0 = (RuleCall)cElseAssignment_4.eContents().get(0);
		private final Keyword cEND_CASEKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//STCaseStatement:
		//    'CASE' selector=STExpression 'OF' cases+=STCaseCases+ (else=STElsePart)? 'END_CASE';
		@Override public ParserRule getRule() { return rule; }
		
		//'CASE' selector=STExpression 'OF' cases+=STCaseCases+ (else=STElsePart)? 'END_CASE'
		public Group getGroup() { return cGroup; }
		
		//'CASE'
		public Keyword getCASEKeyword_0() { return cCASEKeyword_0; }
		
		//selector=STExpression
		public Assignment getSelectorAssignment_1() { return cSelectorAssignment_1; }
		
		//STExpression
		public RuleCall getSelectorSTExpressionParserRuleCall_1_0() { return cSelectorSTExpressionParserRuleCall_1_0; }
		
		//'OF'
		public Keyword getOFKeyword_2() { return cOFKeyword_2; }
		
		//cases+=STCaseCases+
		public Assignment getCasesAssignment_3() { return cCasesAssignment_3; }
		
		//STCaseCases
		public RuleCall getCasesSTCaseCasesParserRuleCall_3_0() { return cCasesSTCaseCasesParserRuleCall_3_0; }
		
		//(else=STElsePart)?
		public Assignment getElseAssignment_4() { return cElseAssignment_4; }
		
		//STElsePart
		public RuleCall getElseSTElsePartParserRuleCall_4_0() { return cElseSTElsePartParserRuleCall_4_0; }
		
		//'END_CASE'
		public Keyword getEND_CASEKeyword_5() { return cEND_CASEKeyword_5; }
	}
	public class STCaseCasesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STCaseCases");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionsSTExpressionParserRuleCall_0_0 = (RuleCall)cConditionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConditionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConditionsSTExpressionParserRuleCall_1_1_0 = (RuleCall)cConditionsAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsSTStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		
		//STCaseCases:
		//    conditions+=STExpression (',' conditions+=STExpression)* ':'=> statements+=STStatement*;
		@Override public ParserRule getRule() { return rule; }
		
		//conditions+=STExpression (',' conditions+=STExpression)* ':'=> statements+=STStatement*
		public Group getGroup() { return cGroup; }
		
		//conditions+=STExpression
		public Assignment getConditionsAssignment_0() { return cConditionsAssignment_0; }
		
		//STExpression
		public RuleCall getConditionsSTExpressionParserRuleCall_0_0() { return cConditionsSTExpressionParserRuleCall_0_0; }
		
		//(',' conditions+=STExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//conditions+=STExpression
		public Assignment getConditionsAssignment_1_1() { return cConditionsAssignment_1_1; }
		
		//STExpression
		public RuleCall getConditionsSTExpressionParserRuleCall_1_1_0() { return cConditionsSTExpressionParserRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//=> statements+=STStatement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_3_0() { return cStatementsSTStatementParserRuleCall_3_0; }
	}
	public class STElsePartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STElsePart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSTElsePartAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cELSEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsSTStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		
		//STElsePart:
		//    {STElsePart} 'ELSE' statements+=STStatement*;
		@Override public ParserRule getRule() { return rule; }
		
		//{STElsePart} 'ELSE' statements+=STStatement*
		public Group getGroup() { return cGroup; }
		
		//{STElsePart}
		public Action getSTElsePartAction_0() { return cSTElsePartAction_0; }
		
		//'ELSE'
		public Keyword getELSEKeyword_1() { return cELSEKeyword_1; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_2_0() { return cStatementsSTStatementParserRuleCall_2_0; }
	}
	public class STForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFORKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVariableSTVarDeclarationCrossReference_1_0 = (CrossReference)cVariableAssignment_1.eContents().get(0);
		private final RuleCall cVariableSTVarDeclarationIDTerminalRuleCall_1_0_1 = (RuleCall)cVariableSTVarDeclarationCrossReference_1_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFromAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFromSTExpressionParserRuleCall_3_0 = (RuleCall)cFromAssignment_3.eContents().get(0);
		private final Keyword cTOKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cToAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cToSTExpressionParserRuleCall_5_0 = (RuleCall)cToAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cBYKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cByAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cBySTExpressionParserRuleCall_6_1_0 = (RuleCall)cByAssignment_6_1.eContents().get(0);
		private final Keyword cDOKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cStatementsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cStatementsSTStatementParserRuleCall_8_0 = (RuleCall)cStatementsAssignment_8.eContents().get(0);
		private final Keyword cEND_FORKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//STForStatement:
		//    'FOR' variable=[STVarDeclaration] ':=' from=STExpression 'TO' to=STExpression ('BY' by=STExpression)? 'DO'
		//    statements+=STStatement*
		//    'END_FOR';
		@Override public ParserRule getRule() { return rule; }
		
		//'FOR' variable=[STVarDeclaration] ':=' from=STExpression 'TO' to=STExpression ('BY' by=STExpression)? 'DO'
		//statements+=STStatement*
		//'END_FOR'
		public Group getGroup() { return cGroup; }
		
		//'FOR'
		public Keyword getFORKeyword_0() { return cFORKeyword_0; }
		
		//variable=[STVarDeclaration]
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//[STVarDeclaration]
		public CrossReference getVariableSTVarDeclarationCrossReference_1_0() { return cVariableSTVarDeclarationCrossReference_1_0; }
		
		//ID
		public RuleCall getVariableSTVarDeclarationIDTerminalRuleCall_1_0_1() { return cVariableSTVarDeclarationIDTerminalRuleCall_1_0_1; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_2() { return cColonEqualsSignKeyword_2; }
		
		//from=STExpression
		public Assignment getFromAssignment_3() { return cFromAssignment_3; }
		
		//STExpression
		public RuleCall getFromSTExpressionParserRuleCall_3_0() { return cFromSTExpressionParserRuleCall_3_0; }
		
		//'TO'
		public Keyword getTOKeyword_4() { return cTOKeyword_4; }
		
		//to=STExpression
		public Assignment getToAssignment_5() { return cToAssignment_5; }
		
		//STExpression
		public RuleCall getToSTExpressionParserRuleCall_5_0() { return cToSTExpressionParserRuleCall_5_0; }
		
		//('BY' by=STExpression)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'BY'
		public Keyword getBYKeyword_6_0() { return cBYKeyword_6_0; }
		
		//by=STExpression
		public Assignment getByAssignment_6_1() { return cByAssignment_6_1; }
		
		//STExpression
		public RuleCall getBySTExpressionParserRuleCall_6_1_0() { return cBySTExpressionParserRuleCall_6_1_0; }
		
		//'DO'
		public Keyword getDOKeyword_7() { return cDOKeyword_7; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment_8() { return cStatementsAssignment_8; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_8_0() { return cStatementsSTStatementParserRuleCall_8_0; }
		
		//'END_FOR'
		public Keyword getEND_FORKeyword_9() { return cEND_FORKeyword_9; }
	}
	public class STWhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STWhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWHILEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionSTExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cDOKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementsSTStatementParserRuleCall_3_0 = (RuleCall)cStatementsAssignment_3.eContents().get(0);
		private final Keyword cEND_WHILEKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//STWhileStatement:
		//    'WHILE' condition=STExpression 'DO'
		//    statements+=STStatement*
		//    'END_WHILE';
		@Override public ParserRule getRule() { return rule; }
		
		//'WHILE' condition=STExpression 'DO'
		//statements+=STStatement*
		//'END_WHILE'
		public Group getGroup() { return cGroup; }
		
		//'WHILE'
		public Keyword getWHILEKeyword_0() { return cWHILEKeyword_0; }
		
		//condition=STExpression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//STExpression
		public RuleCall getConditionSTExpressionParserRuleCall_1_0() { return cConditionSTExpressionParserRuleCall_1_0; }
		
		//'DO'
		public Keyword getDOKeyword_2() { return cDOKeyword_2; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment_3() { return cStatementsAssignment_3; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_3_0() { return cStatementsSTStatementParserRuleCall_3_0; }
		
		//'END_WHILE'
		public Keyword getEND_WHILEKeyword_4() { return cEND_WHILEKeyword_4; }
	}
	public class STRepeatStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STRepeatStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cREPEATKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsSTStatementParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		private final Keyword cUNTILKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cConditionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConditionSTExpressionParserRuleCall_3_0 = (RuleCall)cConditionAssignment_3.eContents().get(0);
		private final Keyword cEND_REPEATKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//STRepeatStatement:
		//    'REPEAT'
		//    statements+=STStatement*
		//    'UNTIL' condition=STExpression
		//    'END_REPEAT';
		@Override public ParserRule getRule() { return rule; }
		
		//'REPEAT'
		//statements+=STStatement*
		//'UNTIL' condition=STExpression
		//'END_REPEAT'
		public Group getGroup() { return cGroup; }
		
		//'REPEAT'
		public Keyword getREPEATKeyword_0() { return cREPEATKeyword_0; }
		
		//statements+=STStatement*
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//STStatement
		public RuleCall getStatementsSTStatementParserRuleCall_1_0() { return cStatementsSTStatementParserRuleCall_1_0; }
		
		//'UNTIL'
		public Keyword getUNTILKeyword_2() { return cUNTILKeyword_2; }
		
		//condition=STExpression
		public Assignment getConditionAssignment_3() { return cConditionAssignment_3; }
		
		//STExpression
		public RuleCall getConditionSTExpressionParserRuleCall_3_0() { return cConditionSTExpressionParserRuleCall_3_0; }
		
		//'END_REPEAT'
		public Keyword getEND_REPEATKeyword_4() { return cEND_REPEATKeyword_4; }
	}
	public class STExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STExpression");
		private final RuleCall cSTSubrangeExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//STExpression returns STExpression:
		//    STSubrangeExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//STSubrangeExpression
		public RuleCall getSTSubrangeExpressionParserRuleCall() { return cSTSubrangeExpressionParserRuleCall; }
	}
	public class STSubrangeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STSubrangeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpSubrangeOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTOrExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STSubrangeExpression returns STExpression:
		//    STOrExpression (({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STOrExpression (({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*
		public Group getGroup() { return cGroup; }
		
		//STOrExpression
		public RuleCall getSTOrExpressionParserRuleCall_0() { return cSTOrExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=SubrangeOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=SubrangeOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//SubrangeOperator
		public RuleCall getOpSubrangeOperatorEnumRuleCall_1_0_1_0() { return cOpSubrangeOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STOrExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STOrExpression
		public RuleCall getRightSTOrExpressionParserRuleCall_1_1_0() { return cRightSTOrExpressionParserRuleCall_1_1_0; }
	}
	public class STOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpOrOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTXorExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STOrExpression returns STExpression:
		//    STXorExpression (({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STXorExpression (({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*
		public Group getGroup() { return cGroup; }
		
		//STXorExpression
		public RuleCall getSTXorExpressionParserRuleCall_0() { return cSTXorExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=OrOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=OrOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//OrOperator
		public RuleCall getOpOrOperatorEnumRuleCall_1_0_1_0() { return cOpOrOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STXorExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STXorExpression
		public RuleCall getRightSTXorExpressionParserRuleCall_1_1_0() { return cRightSTXorExpressionParserRuleCall_1_1_0; }
	}
	public class STXorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STXorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpXorOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTAndExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STXorExpression returns STExpression:
		//    STAndExpression (({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STAndExpression (({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*
		public Group getGroup() { return cGroup; }
		
		//STAndExpression
		public RuleCall getSTAndExpressionParserRuleCall_0() { return cSTAndExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=XorOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=XorOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//XorOperator
		public RuleCall getOpXorOperatorEnumRuleCall_1_0_1_0() { return cOpXorOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STAndExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STAndExpression
		public RuleCall getRightSTAndExpressionParserRuleCall_1_1_0() { return cRightSTAndExpressionParserRuleCall_1_1_0; }
	}
	public class STAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpAndOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTEqualityExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STAndExpression returns STExpression:
		//    STEqualityExpression (({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STEqualityExpression (({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*
		public Group getGroup() { return cGroup; }
		
		//STEqualityExpression
		public RuleCall getSTEqualityExpressionParserRuleCall_0() { return cSTEqualityExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=AndOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=AndOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//AndOperator
		public RuleCall getOpAndOperatorEnumRuleCall_1_0_1_0() { return cOpAndOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STEqualityExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STEqualityExpression
		public RuleCall getRightSTEqualityExpressionParserRuleCall_1_1_0() { return cRightSTEqualityExpressionParserRuleCall_1_1_0; }
	}
	public class STEqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STEqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpEqualityOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTComparisonExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STEqualityExpression returns STExpression:
		//    STComparisonExpression (({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STComparisonExpression (({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*
		public Group getGroup() { return cGroup; }
		
		//STComparisonExpression
		public RuleCall getSTComparisonExpressionParserRuleCall_0() { return cSTComparisonExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=EqualityOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=EqualityOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//EqualityOperator
		public RuleCall getOpEqualityOperatorEnumRuleCall_1_0_1_0() { return cOpEqualityOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STComparisonExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STComparisonExpression
		public RuleCall getRightSTComparisonExpressionParserRuleCall_1_1_0() { return cRightSTComparisonExpressionParserRuleCall_1_1_0; }
	}
	public class STComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTAddSubExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpCompareOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTAddSubExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STComparisonExpression returns STExpression:
		//    STAddSubExpression (({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STAddSubExpression (({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*
		public Group getGroup() { return cGroup; }
		
		//STAddSubExpression
		public RuleCall getSTAddSubExpressionParserRuleCall_0() { return cSTAddSubExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=CompareOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=CompareOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//CompareOperator
		public RuleCall getOpCompareOperatorEnumRuleCall_1_0_1_0() { return cOpCompareOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STAddSubExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STAddSubExpression
		public RuleCall getRightSTAddSubExpressionParserRuleCall_1_1_0() { return cRightSTAddSubExpressionParserRuleCall_1_1_0; }
	}
	public class STAddSubExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STAddSubExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTMulDivModExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpAddSubOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTMulDivModExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STAddSubExpression returns STExpression:
		//    STMulDivModExpression (({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STMulDivModExpression (({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*
		public Group getGroup() { return cGroup; }
		
		//STMulDivModExpression
		public RuleCall getSTMulDivModExpressionParserRuleCall_0() { return cSTMulDivModExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=AddSubOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=AddSubOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//AddSubOperator
		public RuleCall getOpAddSubOperatorEnumRuleCall_1_0_1_0() { return cOpAddSubOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STMulDivModExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STMulDivModExpression
		public RuleCall getRightSTMulDivModExpressionParserRuleCall_1_1_0() { return cRightSTMulDivModExpressionParserRuleCall_1_1_0; }
	}
	public class STMulDivModExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STMulDivModExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTPowerExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpMulDivModOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTPowerExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STMulDivModExpression returns STExpression:
		//    STPowerExpression (({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STPowerExpression (({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*
		public Group getGroup() { return cGroup; }
		
		//STPowerExpression
		public RuleCall getSTPowerExpressionParserRuleCall_0() { return cSTPowerExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=MulDivModOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=MulDivModOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//MulDivModOperator
		public RuleCall getOpMulDivModOperatorEnumRuleCall_1_0_1_0() { return cOpMulDivModOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STPowerExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STPowerExpression
		public RuleCall getRightSTPowerExpressionParserRuleCall_1_1_0() { return cRightSTPowerExpressionParserRuleCall_1_1_0; }
	}
	public class STPowerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STPowerExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cSTBinaryExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpPowerOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightSTUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//STPowerExpression returns STExpression:
		//    STUnaryExpression (({STBinaryExpression.left=current} op=PowerOperator) right=STUnaryExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//STUnaryExpression (({STBinaryExpression.left=current} op=PowerOperator) right=STUnaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//STUnaryExpression
		public RuleCall getSTUnaryExpressionParserRuleCall_0() { return cSTUnaryExpressionParserRuleCall_0; }
		
		//(({STBinaryExpression.left=current} op=PowerOperator) right=STUnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//({STBinaryExpression.left=current} op=PowerOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STBinaryExpression.left=current}
		public Action getSTBinaryExpressionLeftAction_1_0_0() { return cSTBinaryExpressionLeftAction_1_0_0; }
		
		//op=PowerOperator
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//PowerOperator
		public RuleCall getOpPowerOperatorEnumRuleCall_1_0_1_0() { return cOpPowerOperatorEnumRuleCall_1_0_1_0; }
		
		//right=STUnaryExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//STUnaryExpression
		public RuleCall getRightSTUnaryExpressionParserRuleCall_1_1_0() { return cRightSTUnaryExpressionParserRuleCall_1_1_0; }
	}
	public class STUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STUnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTAccessExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cSTUnaryExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpUnaryOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionSTUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		
		//STUnaryExpression returns STExpression:
		//    => STAccessExpression | ({STUnaryExpression} op=UnaryOperator expression=STUnaryExpression);
		@Override public ParserRule getRule() { return rule; }
		
		//=> STAccessExpression | ({STUnaryExpression} op=UnaryOperator expression=STUnaryExpression)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> STAccessExpression
		public RuleCall getSTAccessExpressionParserRuleCall_0() { return cSTAccessExpressionParserRuleCall_0; }
		
		//({STUnaryExpression} op=UnaryOperator expression=STUnaryExpression)
		public Group getGroup_1() { return cGroup_1; }
		
		//{STUnaryExpression}
		public Action getSTUnaryExpressionAction_1_0() { return cSTUnaryExpressionAction_1_0; }
		
		//op=UnaryOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//UnaryOperator
		public RuleCall getOpUnaryOperatorEnumRuleCall_1_1_0() { return cOpUnaryOperatorEnumRuleCall_1_1_0; }
		
		//expression=STUnaryExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//STUnaryExpression
		public RuleCall getExpressionSTUnaryExpressionParserRuleCall_1_2_0() { return cExpressionSTUnaryExpressionParserRuleCall_1_2_0; }
	}
	public class STAccessExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STAccessExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSTPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cSTMemberAccessExpressionReceiverAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cMemberAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final Alternatives cMemberAlternatives_1_0_2_0 = (Alternatives)cMemberAssignment_1_0_2.eContents().get(0);
		private final RuleCall cMemberSTFeatureExpressionParserRuleCall_1_0_2_0_0 = (RuleCall)cMemberAlternatives_1_0_2_0.eContents().get(0);
		private final RuleCall cMemberSTMultibitPartialExpressionParserRuleCall_1_0_2_0_1 = (RuleCall)cMemberAlternatives_1_0_2_0.eContents().get(1);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cSTArrayAccessExpressionReceiverAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cIndexAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cIndexSTExpressionParserRuleCall_1_1_2_0 = (RuleCall)cIndexAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_1_3 = (Group)cGroup_1_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_1_3_0 = (Keyword)cGroup_1_1_3.eContents().get(0);
		private final Assignment cIndexAssignment_1_1_3_1 = (Assignment)cGroup_1_1_3.eContents().get(1);
		private final RuleCall cIndexSTExpressionParserRuleCall_1_1_3_1_0 = (RuleCall)cIndexAssignment_1_1_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_4 = (Keyword)cGroup_1_1.eContents().get(4);
		
		//STAccessExpression returns STExpression:
		//    STPrimaryExpression (({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
		//    STMultibitPartialExpression)) |
		//    ({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']'))*;
		@Override public ParserRule getRule() { return rule; }
		
		//STPrimaryExpression (({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
		//STMultibitPartialExpression)) |
		//({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']'))*
		public Group getGroup() { return cGroup; }
		
		//STPrimaryExpression
		public RuleCall getSTPrimaryExpressionParserRuleCall_0() { return cSTPrimaryExpressionParserRuleCall_0; }
		
		//(({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
		//   STMultibitPartialExpression)) |
		//   ({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']'))*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
		//    STMultibitPartialExpression))
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{STMemberAccessExpression.receiver=current}
		public Action getSTMemberAccessExpressionReceiverAction_1_0_0() { return cSTMemberAccessExpressionReceiverAction_1_0_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0_1() { return cFullStopKeyword_1_0_1; }
		
		//member=(STFeatureExpression |
		//   STMultibitPartialExpression)
		public Assignment getMemberAssignment_1_0_2() { return cMemberAssignment_1_0_2; }
		
		//(STFeatureExpression |
		//    STMultibitPartialExpression)
		public Alternatives getMemberAlternatives_1_0_2_0() { return cMemberAlternatives_1_0_2_0; }
		
		//STFeatureExpression
		public RuleCall getMemberSTFeatureExpressionParserRuleCall_1_0_2_0_0() { return cMemberSTFeatureExpressionParserRuleCall_1_0_2_0_0; }
		
		//STMultibitPartialExpression
		public RuleCall getMemberSTMultibitPartialExpressionParserRuleCall_1_0_2_0_1() { return cMemberSTMultibitPartialExpressionParserRuleCall_1_0_2_0_1; }
		
		//({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']')
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//{STArrayAccessExpression.receiver=current}
		public Action getSTArrayAccessExpressionReceiverAction_1_1_0() { return cSTArrayAccessExpressionReceiverAction_1_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1_1() { return cLeftSquareBracketKeyword_1_1_1; }
		
		//index+=STExpression
		public Assignment getIndexAssignment_1_1_2() { return cIndexAssignment_1_1_2; }
		
		//STExpression
		public RuleCall getIndexSTExpressionParserRuleCall_1_1_2_0() { return cIndexSTExpressionParserRuleCall_1_1_2_0; }
		
		//(',' index+=STExpression)*
		public Group getGroup_1_1_3() { return cGroup_1_1_3; }
		
		//','
		public Keyword getCommaKeyword_1_1_3_0() { return cCommaKeyword_1_1_3_0; }
		
		//index+=STExpression
		public Assignment getIndexAssignment_1_1_3_1() { return cIndexAssignment_1_1_3_1; }
		
		//STExpression
		public RuleCall getIndexSTExpressionParserRuleCall_1_1_3_1_0() { return cIndexSTExpressionParserRuleCall_1_1_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_1_4() { return cRightSquareBracketKeyword_1_1_4; }
	}
	public class STPrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STPrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cSTExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cSTFeatureExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSTLiteralExpressionsParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//STPrimaryExpression returns STExpression:
		//    '(' STExpression ')' | STFeatureExpression | STLiteralExpressions;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' STExpression ')' | STFeatureExpression | STLiteralExpressions
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' STExpression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//STExpression
		public RuleCall getSTExpressionParserRuleCall_0_1() { return cSTExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//STFeatureExpression
		public RuleCall getSTFeatureExpressionParserRuleCall_1() { return cSTFeatureExpressionParserRuleCall_1; }
		
		//STLiteralExpressions
		public RuleCall getSTLiteralExpressionsParserRuleCall_2() { return cSTLiteralExpressionsParserRuleCall_2; }
	}
	public class STFeatureExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STFeatureExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSTFeatureExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFeatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFeatureINamedElementCrossReference_1_0 = (CrossReference)cFeatureAssignment_1.eContents().get(0);
		private final RuleCall cFeatureINamedElementIDTerminalRuleCall_1_0_1 = (RuleCall)cFeatureINamedElementCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParametersSTExpressionParserRuleCall_2_1_0_0 = (RuleCall)cParametersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParametersSTExpressionParserRuleCall_2_1_1_1_0 = (RuleCall)cParametersAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//STFeatureExpression returns STExpression:
		//    {STFeatureExpression} feature=[libraryElement::INamedElement] ( => '(' (parameters+=STExpression (',' parameters+=STExpression)* )? ')' )?;
		@Override public ParserRule getRule() { return rule; }
		
		//{STFeatureExpression} feature=[libraryElement::INamedElement] ( => '(' (parameters+=STExpression (',' parameters+=STExpression)* )? ')' )?
		public Group getGroup() { return cGroup; }
		
		//{STFeatureExpression}
		public Action getSTFeatureExpressionAction_0() { return cSTFeatureExpressionAction_0; }
		
		//feature=[libraryElement::INamedElement]
		public Assignment getFeatureAssignment_1() { return cFeatureAssignment_1; }
		
		//[libraryElement::INamedElement]
		public CrossReference getFeatureINamedElementCrossReference_1_0() { return cFeatureINamedElementCrossReference_1_0; }
		
		//ID
		public RuleCall getFeatureINamedElementIDTerminalRuleCall_1_0_1() { return cFeatureINamedElementIDTerminalRuleCall_1_0_1; }
		
		//( => '(' (parameters+=STExpression (',' parameters+=STExpression)* )? ')' )?
		public Group getGroup_2() { return cGroup_2; }
		
		//=> '('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//(parameters+=STExpression (',' parameters+=STExpression)* )?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//parameters+=STExpression
		public Assignment getParametersAssignment_2_1_0() { return cParametersAssignment_2_1_0; }
		
		//STExpression
		public RuleCall getParametersSTExpressionParserRuleCall_2_1_0_0() { return cParametersSTExpressionParserRuleCall_2_1_0_0; }
		
		//(',' parameters+=STExpression)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//parameters+=STExpression
		public Assignment getParametersAssignment_2_1_1_1() { return cParametersAssignment_2_1_1_1; }
		
		//STExpression
		public RuleCall getParametersSTExpressionParserRuleCall_2_1_1_1_0() { return cParametersSTExpressionParserRuleCall_2_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}
	public class STMultibitPartialExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STMultibitPartialExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSTMultibitPartialExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSpecifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSpecifierSTMultiBitAccessSpecifierEnumRuleCall_1_0 = (RuleCall)cSpecifierAssignment_1.eContents().get(0);
		private final Assignment cIndexAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIndexINTTerminalRuleCall_2_0 = (RuleCall)cIndexAssignment_2.eContents().get(0);
		
		//STMultibitPartialExpression returns STExpression:
		//    {STMultibitPartialExpression} (specifier=STMultiBitAccessSpecifier)? index=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{STMultibitPartialExpression} (specifier=STMultiBitAccessSpecifier)? index=INT
		public Group getGroup() { return cGroup; }
		
		//{STMultibitPartialExpression}
		public Action getSTMultibitPartialExpressionAction_0() { return cSTMultibitPartialExpressionAction_0; }
		
		//(specifier=STMultiBitAccessSpecifier)?
		public Assignment getSpecifierAssignment_1() { return cSpecifierAssignment_1; }
		
		//STMultiBitAccessSpecifier
		public RuleCall getSpecifierSTMultiBitAccessSpecifierEnumRuleCall_1_0() { return cSpecifierSTMultiBitAccessSpecifierEnumRuleCall_1_0; }
		
		//index=INT
		public Assignment getIndexAssignment_2() { return cIndexAssignment_2; }
		
		//INT
		public RuleCall getIndexINTTerminalRuleCall_2_0() { return cIndexINTTerminalRuleCall_2_0; }
	}
	public class STLiteralExpressionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STLiteralExpressions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTNumericLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTDateLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSTTimeLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSTTimeOfDayLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cSTDateAndTimeLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cSTStringLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//STLiteralExpressions returns STExpression:
		//    STNumericLiteral |
		//    STDateLiteral |
		//    STTimeLiteral |
		//    STTimeOfDayLiteral |
		//    STDateAndTimeLiteral |
		//    STStringLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//STNumericLiteral |
		//STDateLiteral |
		//STTimeLiteral |
		//STTimeOfDayLiteral |
		//STDateAndTimeLiteral |
		//STStringLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STNumericLiteral
		public RuleCall getSTNumericLiteralParserRuleCall_0() { return cSTNumericLiteralParserRuleCall_0; }
		
		//STDateLiteral
		public RuleCall getSTDateLiteralParserRuleCall_1() { return cSTDateLiteralParserRuleCall_1; }
		
		//STTimeLiteral
		public RuleCall getSTTimeLiteralParserRuleCall_2() { return cSTTimeLiteralParserRuleCall_2; }
		
		//STTimeOfDayLiteral
		public RuleCall getSTTimeOfDayLiteralParserRuleCall_3() { return cSTTimeOfDayLiteralParserRuleCall_3; }
		
		//STDateAndTimeLiteral
		public RuleCall getSTDateAndTimeLiteralParserRuleCall_4() { return cSTDateAndTimeLiteralParserRuleCall_4; }
		
		//STStringLiteral
		public RuleCall getSTStringLiteralParserRuleCall_5() { return cSTStringLiteralParserRuleCall_5; }
	}
	public class STNumericLiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STNumericLiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOOLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBYTEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWORDKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDWORDKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLWORDKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cSINTKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cINTKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cDINTKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLINTKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cUSINTKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cUINTKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cUDINTKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cULINTKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cREALKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cLREALKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		
		//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
		//STNumericLiteralType returns datatype::DataType:
		//    'BOOL#' |
		//    'BYTE#' |
		//    'WORD#' |
		//    'DWORD#' |
		//    'LWORD#' |
		//    'SINT#' |
		//    'INT#' |
		//    'DINT#' |
		//    'LINT#' |
		//    'USINT#' |
		//    'UINT#' |
		//    'UDINT#' |
		//    'ULINT#' |
		//    'REAL#' |
		//    'LREAL#'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'BOOL#' |
		//'BYTE#' |
		//'WORD#' |
		//'DWORD#' |
		//'LWORD#' |
		//'SINT#' |
		//'INT#' |
		//'DINT#' |
		//'LINT#' |
		//'USINT#' |
		//'UINT#' |
		//'UDINT#' |
		//'ULINT#' |
		//'REAL#' |
		//'LREAL#'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'BOOL#'
		public Keyword getBOOLKeyword_0() { return cBOOLKeyword_0; }
		
		//'BYTE#'
		public Keyword getBYTEKeyword_1() { return cBYTEKeyword_1; }
		
		//'WORD#'
		public Keyword getWORDKeyword_2() { return cWORDKeyword_2; }
		
		//'DWORD#'
		public Keyword getDWORDKeyword_3() { return cDWORDKeyword_3; }
		
		//'LWORD#'
		public Keyword getLWORDKeyword_4() { return cLWORDKeyword_4; }
		
		//'SINT#'
		public Keyword getSINTKeyword_5() { return cSINTKeyword_5; }
		
		//'INT#'
		public Keyword getINTKeyword_6() { return cINTKeyword_6; }
		
		//'DINT#'
		public Keyword getDINTKeyword_7() { return cDINTKeyword_7; }
		
		//'LINT#'
		public Keyword getLINTKeyword_8() { return cLINTKeyword_8; }
		
		//'USINT#'
		public Keyword getUSINTKeyword_9() { return cUSINTKeyword_9; }
		
		//'UINT#'
		public Keyword getUINTKeyword_10() { return cUINTKeyword_10; }
		
		//'UDINT#'
		public Keyword getUDINTKeyword_11() { return cUDINTKeyword_11; }
		
		//'ULINT#'
		public Keyword getULINTKeyword_12() { return cULINTKeyword_12; }
		
		//'REAL#'
		public Keyword getREALKeyword_13() { return cREALKeyword_13; }
		
		//'LREAL#'
		public Keyword getLREALKeyword_14() { return cLREALKeyword_14; }
	}
	public class STNumericLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STNumericLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSTNumericLiteralTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueBoolLiteralParserRuleCall_1_0_0 = (RuleCall)cValueAlternatives_1_0.eContents().get(0);
		private final RuleCall cValueNumberParserRuleCall_1_0_1 = (RuleCall)cValueAlternatives_1_0.eContents().get(1);
		private final RuleCall cValueNON_DECIMALTerminalRuleCall_1_0_2 = (RuleCall)cValueAlternatives_1_0.eContents().get(2);
		
		//STNumericLiteral:
		//    (type=STNumericLiteralType)?
		//    value=(BoolLiteral | Number | NON_DECIMAL);
		@Override public ParserRule getRule() { return rule; }
		
		//(type=STNumericLiteralType)?
		//value=(BoolLiteral | Number | NON_DECIMAL)
		public Group getGroup() { return cGroup; }
		
		//(type=STNumericLiteralType)?
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//STNumericLiteralType
		public RuleCall getTypeSTNumericLiteralTypeParserRuleCall_0_0() { return cTypeSTNumericLiteralTypeParserRuleCall_0_0; }
		
		//value=(BoolLiteral | Number | NON_DECIMAL)
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//(BoolLiteral | Number | NON_DECIMAL)
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }
		
		//BoolLiteral
		public RuleCall getValueBoolLiteralParserRuleCall_1_0_0() { return cValueBoolLiteralParserRuleCall_1_0_0; }
		
		//Number
		public RuleCall getValueNumberParserRuleCall_1_0_1() { return cValueNumberParserRuleCall_1_0_1; }
		
		//NON_DECIMAL
		public RuleCall getValueNON_DECIMALTerminalRuleCall_1_0_2() { return cValueNON_DECIMALTerminalRuleCall_1_0_2; }
	}
	public class STDateLiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STDateLiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDATEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLDATEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLDKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
		//STDateLiteralType returns datatype::DataType:
		//    'DATE#' |
		//    'LDATE#' |
		//    'D#' |
		//    'LD#'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'DATE#' |
		//'LDATE#' |
		//'D#' |
		//'LD#'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'DATE#'
		public Keyword getDATEKeyword_0() { return cDATEKeyword_0; }
		
		//'LDATE#'
		public Keyword getLDATEKeyword_1() { return cLDATEKeyword_1; }
		
		//'D#'
		public Keyword getDKeyword_2() { return cDKeyword_2; }
		
		//'LD#'
		public Keyword getLDKeyword_3() { return cLDKeyword_3; }
	}
	public class STDateLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STDateLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSTDateLiteralTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueDateParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//STDateLiteral:
		//    type=STDateLiteralType value=Date;
		@Override public ParserRule getRule() { return rule; }
		
		//type=STDateLiteralType value=Date
		public Group getGroup() { return cGroup; }
		
		//type=STDateLiteralType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//STDateLiteralType
		public RuleCall getTypeSTDateLiteralTypeParserRuleCall_0_0() { return cTypeSTDateLiteralTypeParserRuleCall_0_0; }
		
		//value=Date
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Date
		public RuleCall getValueDateParserRuleCall_1_0() { return cValueDateParserRuleCall_1_0; }
	}
	public class STTimeLiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STTimeLiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTIMEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLTIMEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
		//STTimeLiteralType returns datatype::DataType:
		//    'TIME#' |
		//    'LTIME#' |
		//    'T#' |
		//    'LT#'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'TIME#' |
		//'LTIME#' |
		//'T#' |
		//'LT#'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'TIME#'
		public Keyword getTIMEKeyword_0() { return cTIMEKeyword_0; }
		
		//'LTIME#'
		public Keyword getLTIMEKeyword_1() { return cLTIMEKeyword_1; }
		
		//'T#'
		public Keyword getTKeyword_2() { return cTKeyword_2; }
		
		//'LT#'
		public Keyword getLTKeyword_3() { return cLTKeyword_3; }
	}
	public class STTimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STTimeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSTTimeLiteralTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueTimeParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//STTimeLiteral:
		//    type=STTimeLiteralType value=Time;
		@Override public ParserRule getRule() { return rule; }
		
		//type=STTimeLiteralType value=Time
		public Group getGroup() { return cGroup; }
		
		//type=STTimeLiteralType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//STTimeLiteralType
		public RuleCall getTypeSTTimeLiteralTypeParserRuleCall_0_0() { return cTypeSTTimeLiteralTypeParserRuleCall_0_0; }
		
		//value=Time
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//Time
		public RuleCall getValueTimeParserRuleCall_1_0() { return cValueTimeParserRuleCall_1_0; }
	}
	public class STTimeOfDayLiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STTimeOfDayLiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTIME_OF_DAYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTODKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLTODKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
		//STTimeOfDayLiteralType returns datatype::DataType:
		//    'TIME_OF_DAY#' |
		//    'TOD#' |
		//    'LTOD#'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'TIME_OF_DAY#' |
		//'TOD#' |
		//'LTOD#'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'TIME_OF_DAY#'
		public Keyword getTIME_OF_DAYKeyword_0() { return cTIME_OF_DAYKeyword_0; }
		
		//'TOD#'
		public Keyword getTODKeyword_1() { return cTODKeyword_1; }
		
		//'LTOD#'
		public Keyword getLTODKeyword_2() { return cLTODKeyword_2; }
	}
	public class STTimeOfDayLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STTimeOfDayLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSTTimeOfDayLiteralTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueTimeOfDayParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//STTimeOfDayLiteral:
		//    type=STTimeOfDayLiteralType value=TimeOfDay;
		@Override public ParserRule getRule() { return rule; }
		
		//type=STTimeOfDayLiteralType value=TimeOfDay
		public Group getGroup() { return cGroup; }
		
		//type=STTimeOfDayLiteralType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//STTimeOfDayLiteralType
		public RuleCall getTypeSTTimeOfDayLiteralTypeParserRuleCall_0_0() { return cTypeSTTimeOfDayLiteralTypeParserRuleCall_0_0; }
		
		//value=TimeOfDay
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//TimeOfDay
		public RuleCall getValueTimeOfDayParserRuleCall_1_0() { return cValueTimeOfDayParserRuleCall_1_0; }
	}
	public class STDateAndTimeLiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STDateAndTimeLiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDATE_AND_TIMEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLDATE_AND_TIMEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLDTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
		//STDateAndTimeLiteralType returns datatype::DataType:
		//    'DATE_AND_TIME#' |
		//    'LDATE_AND_TIME#' |
		//    'DT#' |
		//    'LDT#'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'DATE_AND_TIME#' |
		//'LDATE_AND_TIME#' |
		//'DT#' |
		//'LDT#'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'DATE_AND_TIME#'
		public Keyword getDATE_AND_TIMEKeyword_0() { return cDATE_AND_TIMEKeyword_0; }
		
		//'LDATE_AND_TIME#'
		public Keyword getLDATE_AND_TIMEKeyword_1() { return cLDATE_AND_TIMEKeyword_1; }
		
		//'DT#'
		public Keyword getDTKeyword_2() { return cDTKeyword_2; }
		
		//'LDT#'
		public Keyword getLDTKeyword_3() { return cLDTKeyword_3; }
	}
	public class STDateAndTimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STDateAndTimeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSTDateAndTimeLiteralTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cDateValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDateValueDateParserRuleCall_1_0 = (RuleCall)cDateValueAssignment_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTimeOfDayValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTimeOfDayValueTimeOfDayParserRuleCall_3_0 = (RuleCall)cTimeOfDayValueAssignment_3.eContents().get(0);
		
		//STDateAndTimeLiteral:
		//    type=STDateAndTimeLiteralType dateValue=Date '-' timeOfDayValue=TimeOfDay;
		@Override public ParserRule getRule() { return rule; }
		
		//type=STDateAndTimeLiteralType dateValue=Date '-' timeOfDayValue=TimeOfDay
		public Group getGroup() { return cGroup; }
		
		//type=STDateAndTimeLiteralType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//STDateAndTimeLiteralType
		public RuleCall getTypeSTDateAndTimeLiteralTypeParserRuleCall_0_0() { return cTypeSTDateAndTimeLiteralTypeParserRuleCall_0_0; }
		
		//dateValue=Date
		public Assignment getDateValueAssignment_1() { return cDateValueAssignment_1; }
		
		//Date
		public RuleCall getDateValueDateParserRuleCall_1_0() { return cDateValueDateParserRuleCall_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_2() { return cHyphenMinusKeyword_2; }
		
		//timeOfDayValue=TimeOfDay
		public Assignment getTimeOfDayValueAssignment_3() { return cTimeOfDayValueAssignment_3; }
		
		//TimeOfDay
		public RuleCall getTimeOfDayValueTimeOfDayParserRuleCall_3_0() { return cTimeOfDayValueTimeOfDayParserRuleCall_3_0; }
	}
	public class STStringLiteralTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STStringLiteralType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSTRINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWSTRINGKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCHARKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cWCHARKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
		//STStringLiteralType returns datatype::DataType:
		//    'STRING#' |
		//    'WSTRING#' |
		//    'CHAR#' |
		//    'WCHAR#'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'STRING#' |
		//'WSTRING#' |
		//'CHAR#' |
		//'WCHAR#'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'STRING#'
		public Keyword getSTRINGKeyword_0() { return cSTRINGKeyword_0; }
		
		//'WSTRING#'
		public Keyword getWSTRINGKeyword_1() { return cWSTRINGKeyword_1; }
		
		//'CHAR#'
		public Keyword getCHARKeyword_2() { return cCHARKeyword_2; }
		
		//'WCHAR#'
		public Keyword getWCHARKeyword_3() { return cWCHARKeyword_3; }
	}
	public class STStringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STStringLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeSTStringLiteralTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cValueAlternatives_1_0 = (Alternatives)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0_0 = (RuleCall)cValueAlternatives_1_0.eContents().get(0);
		private final RuleCall cValueWSTRINGTerminalRuleCall_1_0_1 = (RuleCall)cValueAlternatives_1_0.eContents().get(1);
		
		//STStringLiteral:
		//    (type=STStringLiteralType)? value=(STRING|WSTRING);
		@Override public ParserRule getRule() { return rule; }
		
		//(type=STStringLiteralType)? value=(STRING|WSTRING)
		public Group getGroup() { return cGroup; }
		
		//(type=STStringLiteralType)?
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//STStringLiteralType
		public RuleCall getTypeSTStringLiteralTypeParserRuleCall_0_0() { return cTypeSTStringLiteralTypeParserRuleCall_0_0; }
		
		//value=(STRING|WSTRING)
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//(STRING|WSTRING)
		public Alternatives getValueAlternatives_1_0() { return cValueAlternatives_1_0; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0_0() { return cValueSTRINGTerminalRuleCall_1_0_0; }
		
		//WSTRING
		public RuleCall getValueWSTRINGTerminalRuleCall_1_0_1() { return cValueWSTRINGTerminalRuleCall_1_0_1; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//    ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class BoolLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.BoolLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTRUEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFALSEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// BOOLs are internally always stored as numerical value. 0 = FALSE, 1 = TRUE
		//BoolLiteral returns ecore::EBigDecimal:
		//    'TRUE' | 'FALSE'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'TRUE' | 'FALSE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_0() { return cTRUEKeyword_0; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_1() { return cFALSEKeyword_1; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.Number");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final RuleCall cEXT_INTTerminalRuleCall_2_1_0 = (RuleCall)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1_1 = (RuleCall)cAlternatives_2_1.eContents().get(1);
		
		//Number returns ecore::EBigDecimal:
		//    ('+' | '-')? INT (=> '.' (EXT_INT | INT))?;
		@Override public ParserRule getRule() { return rule; }
		
		//('+' | '-')? INT (=> '.' (EXT_INT | INT))?
		public Group getGroup() { return cGroup; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_0() { return cPlusSignKeyword_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0_1() { return cHyphenMinusKeyword_0_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//(=> '.' (EXT_INT | INT))?
		public Group getGroup_2() { return cGroup_2; }
		
		//=> '.'
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }
		
		//(EXT_INT | INT)
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }
		
		//EXT_INT
		public RuleCall getEXT_INTTerminalRuleCall_2_1_0() { return cEXT_INTTerminalRuleCall_2_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2_1_1() { return cINTTerminalRuleCall_2_1_1; }
	}
	public class DateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.Date");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Date returns ecore::EDate:
		//    INT '-' INT '-' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '-' INT '-' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4() { return cINTTerminalRuleCall_4; }
	}
	public class TimeOfDayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.TimeOfDay");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cFullStopKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		
		//TimeOfDay:
		//    INT ':' INT ':' INT (=> '.' INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//INT ':' INT ':' INT (=> '.' INT)?
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4() { return cINTTerminalRuleCall_4; }
		
		//(=> '.' INT)?
		public Group getGroup_5() { return cGroup_5; }
		
		//=> '.'
		public Keyword getFullStopKeyword_5_0() { return cFullStopKeyword_5_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_5_1() { return cINTTerminalRuleCall_5_1; }
	}
	public class TimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.Time");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cDKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cHKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cMKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cSKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		private final Keyword cMSKeyword_1_4 = (Keyword)cAlternatives_1.eContents().get(4);
		private final Keyword cUSKeyword_1_5 = (Keyword)cAlternatives_1.eContents().get(5);
		private final Keyword cNSKeyword_1_6 = (Keyword)cAlternatives_1.eContents().get(6);
		private final Keyword c_Keyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Time:
		//    (Number ('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS') ('_')?)+;
		@Override public ParserRule getRule() { return rule; }
		
		//(Number ('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS') ('_')?)+
		public Group getGroup() { return cGroup; }
		
		//Number
		public RuleCall getNumberParserRuleCall_0() { return cNumberParserRuleCall_0; }
		
		//('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'D'
		public Keyword getDKeyword_1_0() { return cDKeyword_1_0; }
		
		//'H'
		public Keyword getHKeyword_1_1() { return cHKeyword_1_1; }
		
		//'M'
		public Keyword getMKeyword_1_2() { return cMKeyword_1_2; }
		
		//'S'
		public Keyword getSKeyword_1_3() { return cSKeyword_1_3; }
		
		//'MS'
		public Keyword getMSKeyword_1_4() { return cMSKeyword_1_4; }
		
		//'US'
		public Keyword getUSKeyword_1_5() { return cUSKeyword_1_5; }
		
		//'NS'
		public Keyword getNSKeyword_1_6() { return cNSKeyword_1_6; }
		
		//('_')?
		public Keyword get_Keyword_2() { return c_Keyword_2; }
	}
	
	public class SubrangeOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.SubrangeOperator");
		private final EnumLiteralDeclaration cRangeEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cRangeFullStopFullStopKeyword_0 = (Keyword)cRangeEnumLiteralDeclaration.eContents().get(0);
		
		//enum SubrangeOperator returns BinaryOperator: Range='..';
		public EnumRule getRule() { return rule; }
		
		//Range='..'
		public EnumLiteralDeclaration getRangeEnumLiteralDeclaration() { return cRangeEnumLiteralDeclaration; }
		
		//'..'
		public Keyword getRangeFullStopFullStopKeyword_0() { return cRangeFullStopFullStopKeyword_0; }
	}
	public class OrOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.OrOperator");
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cORORKeyword_0 = (Keyword)cOREnumLiteralDeclaration.eContents().get(0);
		
		//enum OrOperator returns BinaryOperator: OR;
		public EnumRule getRule() { return rule; }
		
		//OR
		public EnumLiteralDeclaration getOREnumLiteralDeclaration() { return cOREnumLiteralDeclaration; }
		
		public Keyword getORORKeyword_0() { return cORORKeyword_0; }
	}
	public class XorOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.XorOperator");
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cXORXORKeyword_0 = (Keyword)cXOREnumLiteralDeclaration.eContents().get(0);
		
		//enum XorOperator returns BinaryOperator: XOR;
		public EnumRule getRule() { return rule; }
		
		//XOR
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration() { return cXOREnumLiteralDeclaration; }
		
		public Keyword getXORXORKeyword_0() { return cXORXORKeyword_0; }
	}
	public class AndOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.AndOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDANDKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cAMPERSANDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cAMPERSANDAmpersandKeyword_1_0 = (Keyword)cAMPERSANDEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AndOperator returns BinaryOperator: AND | AMPERSAND='&';
		public EnumRule getRule() { return rule; }
		
		//AND | AMPERSAND='&'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AND
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }
		
		public Keyword getANDANDKeyword_0_0() { return cANDANDKeyword_0_0; }
		
		//AMPERSAND='&'
		public EnumLiteralDeclaration getAMPERSANDEnumLiteralDeclaration_1() { return cAMPERSANDEnumLiteralDeclaration_1; }
		
		//'&'
		public Keyword getAMPERSANDAmpersandKeyword_1_0() { return cAMPERSANDAmpersandKeyword_1_0; }
	}
	public class EqualityOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.EqualityOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNELessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cNEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EqualityOperator returns BinaryOperator: EQ='=' | NE='<>';
		public EnumRule getRule() { return rule; }
		
		//EQ='=' | NE='<>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQ='='
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }
		
		//NE='<>'
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_1() { return cNEEnumLiteralDeclaration_1; }
		
		//'<>'
		public Keyword getNELessThanSignGreaterThanSignKeyword_1_0() { return cNELessThanSignGreaterThanSignKeyword_1_0; }
	}
	public class CompareOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.CompareOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLTLessThanSignKeyword_0_0 = (Keyword)cLTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLELessThanSignEqualsSignKeyword_1_0 = (Keyword)cLEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGTGreaterThanSignKeyword_2_0 = (Keyword)cGTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_3_0 = (Keyword)cGEEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum CompareOperator returns BinaryOperator: LT='<' | LE='<=' | GT='>' | GE='>=';
		public EnumRule getRule() { return rule; }
		
		//LT='<' | LE='<=' | GT='>' | GE='>='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LT='<'
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_0() { return cLTEnumLiteralDeclaration_0; }
		
		//'<'
		public Keyword getLTLessThanSignKeyword_0_0() { return cLTLessThanSignKeyword_0_0; }
		
		//LE='<='
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_1() { return cLEEnumLiteralDeclaration_1; }
		
		//'<='
		public Keyword getLELessThanSignEqualsSignKeyword_1_0() { return cLELessThanSignEqualsSignKeyword_1_0; }
		
		//GT='>'
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_2() { return cGTEnumLiteralDeclaration_2; }
		
		//'>'
		public Keyword getGTGreaterThanSignKeyword_2_0() { return cGTGreaterThanSignKeyword_2_0; }
		
		//GE='>='
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_3() { return cGEEnumLiteralDeclaration_3; }
		
		//'>='
		public Keyword getGEGreaterThanSignEqualsSignKeyword_3_0() { return cGEGreaterThanSignEqualsSignKeyword_3_0; }
	}
	public class AddSubOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.AddSubOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDPlusSignKeyword_0_0 = (Keyword)cADDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBHyphenMinusKeyword_1_0 = (Keyword)cSUBEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AddSubOperator returns BinaryOperator: ADD='+' | SUB='-';
		public EnumRule getRule() { return rule; }
		
		//ADD='+' | SUB='-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ADD='+'
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_0() { return cADDEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getADDPlusSignKeyword_0_0() { return cADDPlusSignKeyword_0_0; }
		
		//SUB='-'
		public EnumLiteralDeclaration getSUBEnumLiteralDeclaration_1() { return cSUBEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getSUBHyphenMinusKeyword_1_0() { return cSUBHyphenMinusKeyword_1_0; }
	}
	public class MulDivModOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.MulDivModOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULAsteriskKeyword_0_0 = (Keyword)cMULEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODMODKeyword_2_0 = (Keyword)cMODEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum MulDivModOperator returns BinaryOperator: MUL='*' | DIV='/' | MOD;
		public EnumRule getRule() { return rule; }
		
		//MUL='*' | DIV='/' | MOD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MUL='*'
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_0() { return cMULEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getMULAsteriskKeyword_0_0() { return cMULAsteriskKeyword_0_0; }
		
		//DIV='/'
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
		
		//MOD
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_2() { return cMODEnumLiteralDeclaration_2; }
		
		public Keyword getMODMODKeyword_2_0() { return cMODMODKeyword_2_0; }
	}
	public class PowerOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.PowerOperator");
		private final EnumLiteralDeclaration cPOWEREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPOWERAsteriskAsteriskKeyword_0 = (Keyword)cPOWEREnumLiteralDeclaration.eContents().get(0);
		
		//enum PowerOperator returns BinaryOperator: POWER='**';
		public EnumRule getRule() { return rule; }
		
		//POWER='**'
		public EnumLiteralDeclaration getPOWEREnumLiteralDeclaration() { return cPOWEREnumLiteralDeclaration; }
		
		//'**'
		public Keyword getPOWERAsteriskAsteriskKeyword_0() { return cPOWERAsteriskAsteriskKeyword_0; }
	}
	public class UnaryOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMINUSHyphenMinusKeyword_0_0 = (Keyword)cMINUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPLUSPlusSignKeyword_1_0 = (Keyword)cPLUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNOTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNOTNOTKeyword_2_0 = (Keyword)cNOTEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum UnaryOperator returns UnaryOperator: MINUS='-' | PLUS='+' | NOT;
		public EnumRule getRule() { return rule; }
		
		//MINUS='-' | PLUS='+' | NOT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_0() { return cMINUSEnumLiteralDeclaration_0; }
		
		//'-'
		public Keyword getMINUSHyphenMinusKeyword_0_0() { return cMINUSHyphenMinusKeyword_0_0; }
		
		//PLUS='+'
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_1() { return cPLUSEnumLiteralDeclaration_1; }
		
		//'+'
		public Keyword getPLUSPlusSignKeyword_1_0() { return cPLUSPlusSignKeyword_1_0; }
		
		//NOT
		public EnumLiteralDeclaration getNOTEnumLiteralDeclaration_2() { return cNOTEnumLiteralDeclaration_2; }
		
		public Keyword getNOTNOTKeyword_2_0() { return cNOTNOTKeyword_2_0; }
	}
	public class STMultiBitAccessSpecifierElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STMultiBitAccessSpecifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLLKeyword_0_0 = (Keyword)cLEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDDKeyword_1_0 = (Keyword)cDEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cWEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cWWKeyword_2_0 = (Keyword)cWEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cBEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cBBKeyword_3_0 = (Keyword)cBEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cXEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cXXKeyword_4_0 = (Keyword)cXEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum STMultiBitAccessSpecifier:
		//    L='%L' | D='%D' | W='%W' | B='%B' | X='%X';
		public EnumRule getRule() { return rule; }
		
		//L='%L' | D='%D' | W='%W' | B='%B' | X='%X'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//L='%L'
		public EnumLiteralDeclaration getLEnumLiteralDeclaration_0() { return cLEnumLiteralDeclaration_0; }
		
		//'%L'
		public Keyword getLLKeyword_0_0() { return cLLKeyword_0_0; }
		
		//D='%D'
		public EnumLiteralDeclaration getDEnumLiteralDeclaration_1() { return cDEnumLiteralDeclaration_1; }
		
		//'%D'
		public Keyword getDDKeyword_1_0() { return cDDKeyword_1_0; }
		
		//W='%W'
		public EnumLiteralDeclaration getWEnumLiteralDeclaration_2() { return cWEnumLiteralDeclaration_2; }
		
		//'%W'
		public Keyword getWWKeyword_2_0() { return cWWKeyword_2_0; }
		
		//B='%B'
		public EnumLiteralDeclaration getBEnumLiteralDeclaration_3() { return cBEnumLiteralDeclaration_3; }
		
		//'%B'
		public Keyword getBBKeyword_3_0() { return cBBKeyword_3_0; }
		
		//X='%X'
		public EnumLiteralDeclaration getXEnumLiteralDeclaration_4() { return cXEnumLiteralDeclaration_4; }
		
		//'%X'
		public Keyword getXXKeyword_4_0() { return cXXKeyword_4_0; }
	}
	
	private final CodeElements pCode;
	private final VarDeclarationBlockElements pVarDeclarationBlock;
	private final VarTempDeclarationBlockElements pVarTempDeclarationBlock;
	private final VarInputDeclarationBlockElements pVarInputDeclarationBlock;
	private final VarOutputDeclarationBlockElements pVarOutputDeclarationBlock;
	private final VarDeclarationElements pVarDeclaration;
	private final InitializerExpressionElements pInitializerExpression;
	private final ArrayInitializerExpressionElements pArrayInitializerExpression;
	private final ArrayInitElementElements pArrayInitElement;
	private final STStatementElements pSTStatement;
	private final STAssignmentStatementElements pSTAssignmentStatement;
	private final STIfStatementElements pSTIfStatement;
	private final STElseIfPartElements pSTElseIfPart;
	private final STCaseStatementElements pSTCaseStatement;
	private final STCaseCasesElements pSTCaseCases;
	private final STElsePartElements pSTElsePart;
	private final STForStatementElements pSTForStatement;
	private final STWhileStatementElements pSTWhileStatement;
	private final STRepeatStatementElements pSTRepeatStatement;
	private final STExpressionElements pSTExpression;
	private final SubrangeOperatorElements eSubrangeOperator;
	private final STSubrangeExpressionElements pSTSubrangeExpression;
	private final OrOperatorElements eOrOperator;
	private final STOrExpressionElements pSTOrExpression;
	private final XorOperatorElements eXorOperator;
	private final STXorExpressionElements pSTXorExpression;
	private final AndOperatorElements eAndOperator;
	private final STAndExpressionElements pSTAndExpression;
	private final EqualityOperatorElements eEqualityOperator;
	private final STEqualityExpressionElements pSTEqualityExpression;
	private final CompareOperatorElements eCompareOperator;
	private final STComparisonExpressionElements pSTComparisonExpression;
	private final AddSubOperatorElements eAddSubOperator;
	private final STAddSubExpressionElements pSTAddSubExpression;
	private final MulDivModOperatorElements eMulDivModOperator;
	private final STMulDivModExpressionElements pSTMulDivModExpression;
	private final PowerOperatorElements ePowerOperator;
	private final STPowerExpressionElements pSTPowerExpression;
	private final UnaryOperatorElements eUnaryOperator;
	private final STUnaryExpressionElements pSTUnaryExpression;
	private final STAccessExpressionElements pSTAccessExpression;
	private final STPrimaryExpressionElements pSTPrimaryExpression;
	private final STFeatureExpressionElements pSTFeatureExpression;
	private final STMultiBitAccessSpecifierElements eSTMultiBitAccessSpecifier;
	private final STMultibitPartialExpressionElements pSTMultibitPartialExpression;
	private final STLiteralExpressionsElements pSTLiteralExpressions;
	private final STNumericLiteralTypeElements pSTNumericLiteralType;
	private final STNumericLiteralElements pSTNumericLiteral;
	private final STDateLiteralTypeElements pSTDateLiteralType;
	private final STDateLiteralElements pSTDateLiteral;
	private final STTimeLiteralTypeElements pSTTimeLiteralType;
	private final STTimeLiteralElements pSTTimeLiteral;
	private final STTimeOfDayLiteralTypeElements pSTTimeOfDayLiteralType;
	private final STTimeOfDayLiteralElements pSTTimeOfDayLiteral;
	private final STDateAndTimeLiteralTypeElements pSTDateAndTimeLiteralType;
	private final STDateAndTimeLiteralElements pSTDateAndTimeLiteral;
	private final STStringLiteralTypeElements pSTStringLiteralType;
	private final STStringLiteralElements pSTStringLiteral;
	private final QualifiedNameElements pQualifiedName;
	private final BoolLiteralElements pBoolLiteral;
	private final NumberElements pNumber;
	private final DateElements pDate;
	private final TimeOfDayElements pTimeOfDay;
	private final TimeElements pTime;
	private final TerminalRule tHEX_DIGIT;
	private final TerminalRule tNON_DECIMAL;
	private final TerminalRule tEXT_INT;
	private final TerminalRule tINT;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	private final TerminalRule tWSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public STCoreGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pCode = new CodeElements();
		this.pVarDeclarationBlock = new VarDeclarationBlockElements();
		this.pVarTempDeclarationBlock = new VarTempDeclarationBlockElements();
		this.pVarInputDeclarationBlock = new VarInputDeclarationBlockElements();
		this.pVarOutputDeclarationBlock = new VarOutputDeclarationBlockElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pInitializerExpression = new InitializerExpressionElements();
		this.pArrayInitializerExpression = new ArrayInitializerExpressionElements();
		this.pArrayInitElement = new ArrayInitElementElements();
		this.pSTStatement = new STStatementElements();
		this.pSTAssignmentStatement = new STAssignmentStatementElements();
		this.pSTIfStatement = new STIfStatementElements();
		this.pSTElseIfPart = new STElseIfPartElements();
		this.pSTCaseStatement = new STCaseStatementElements();
		this.pSTCaseCases = new STCaseCasesElements();
		this.pSTElsePart = new STElsePartElements();
		this.pSTForStatement = new STForStatementElements();
		this.pSTWhileStatement = new STWhileStatementElements();
		this.pSTRepeatStatement = new STRepeatStatementElements();
		this.pSTExpression = new STExpressionElements();
		this.eSubrangeOperator = new SubrangeOperatorElements();
		this.pSTSubrangeExpression = new STSubrangeExpressionElements();
		this.eOrOperator = new OrOperatorElements();
		this.pSTOrExpression = new STOrExpressionElements();
		this.eXorOperator = new XorOperatorElements();
		this.pSTXorExpression = new STXorExpressionElements();
		this.eAndOperator = new AndOperatorElements();
		this.pSTAndExpression = new STAndExpressionElements();
		this.eEqualityOperator = new EqualityOperatorElements();
		this.pSTEqualityExpression = new STEqualityExpressionElements();
		this.eCompareOperator = new CompareOperatorElements();
		this.pSTComparisonExpression = new STComparisonExpressionElements();
		this.eAddSubOperator = new AddSubOperatorElements();
		this.pSTAddSubExpression = new STAddSubExpressionElements();
		this.eMulDivModOperator = new MulDivModOperatorElements();
		this.pSTMulDivModExpression = new STMulDivModExpressionElements();
		this.ePowerOperator = new PowerOperatorElements();
		this.pSTPowerExpression = new STPowerExpressionElements();
		this.eUnaryOperator = new UnaryOperatorElements();
		this.pSTUnaryExpression = new STUnaryExpressionElements();
		this.pSTAccessExpression = new STAccessExpressionElements();
		this.pSTPrimaryExpression = new STPrimaryExpressionElements();
		this.pSTFeatureExpression = new STFeatureExpressionElements();
		this.eSTMultiBitAccessSpecifier = new STMultiBitAccessSpecifierElements();
		this.pSTMultibitPartialExpression = new STMultibitPartialExpressionElements();
		this.pSTLiteralExpressions = new STLiteralExpressionsElements();
		this.pSTNumericLiteralType = new STNumericLiteralTypeElements();
		this.pSTNumericLiteral = new STNumericLiteralElements();
		this.pSTDateLiteralType = new STDateLiteralTypeElements();
		this.pSTDateLiteral = new STDateLiteralElements();
		this.pSTTimeLiteralType = new STTimeLiteralTypeElements();
		this.pSTTimeLiteral = new STTimeLiteralElements();
		this.pSTTimeOfDayLiteralType = new STTimeOfDayLiteralTypeElements();
		this.pSTTimeOfDayLiteral = new STTimeOfDayLiteralElements();
		this.pSTDateAndTimeLiteralType = new STDateAndTimeLiteralTypeElements();
		this.pSTDateAndTimeLiteral = new STDateAndTimeLiteralElements();
		this.pSTStringLiteralType = new STStringLiteralTypeElements();
		this.pSTStringLiteral = new STStringLiteralElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pBoolLiteral = new BoolLiteralElements();
		this.pNumber = new NumberElements();
		this.pDate = new DateElements();
		this.pTimeOfDay = new TimeOfDayElements();
		this.pTime = new TimeElements();
		this.tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.HEX_DIGIT");
		this.tNON_DECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.NON_DECIMAL");
		this.tEXT_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.EXT_INT");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.INT");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.STRING");
		this.tWSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.WSTRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.eclipse.fordiac.ide.structuredtextcore.STCore.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.fordiac.ide.structuredtextcore.STCore".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Code:
	//    statements+=STStatement*;
	public CodeElements getCodeAccess() {
		return pCode;
	}
	
	public ParserRule getCodeRule() {
		return getCodeAccess().getRule();
	}
	
	//VarDeclarationBlock returns VarDeclarationBlock:
	//    {VarDeclarationBlock} 'VAR' (constant?='CONSTANT')?
	//    varDeclarations+=VarDeclaration*
	//    'END_VAR';
	public VarDeclarationBlockElements getVarDeclarationBlockAccess() {
		return pVarDeclarationBlock;
	}
	
	public ParserRule getVarDeclarationBlockRule() {
		return getVarDeclarationBlockAccess().getRule();
	}
	
	//VarTempDeclarationBlock returns VarDeclarationBlock:
	//    {VarDeclarationBlock} 'VAR_TEMP' (constant?='CONSTANT')?
	//    varDeclarations+=VarDeclaration*
	//    'END_VAR';
	public VarTempDeclarationBlockElements getVarTempDeclarationBlockAccess() {
		return pVarTempDeclarationBlock;
	}
	
	public ParserRule getVarTempDeclarationBlockRule() {
		return getVarTempDeclarationBlockAccess().getRule();
	}
	
	//VarInputDeclarationBlock returns VarDeclarationBlock:
	//    {VarDeclarationBlock} 'VAR_INPUT' (constant?='CONSTANT')?
	//    varDeclarations+=VarDeclaration*
	//    'END_VAR';
	public VarInputDeclarationBlockElements getVarInputDeclarationBlockAccess() {
		return pVarInputDeclarationBlock;
	}
	
	public ParserRule getVarInputDeclarationBlockRule() {
		return getVarInputDeclarationBlockAccess().getRule();
	}
	
	//VarOutputDeclarationBlock returns VarDeclarationBlock:
	//    {VarDeclarationBlock} 'VAR_OUTPUT' (constant?='CONSTANT')?
	//    varDeclarations+=VarDeclaration*
	//    'END_VAR';
	public VarOutputDeclarationBlockElements getVarOutputDeclarationBlockAccess() {
		return pVarOutputDeclarationBlock;
	}
	
	public ParserRule getVarOutputDeclarationBlockRule() {
		return getVarOutputDeclarationBlockAccess().getRule();
	}
	
	//VarDeclaration returns libraryElement::INamedElement:
	//    {STVarDeclaration}
	//    name=ID ('AT' locatedAt=[libraryElement::INamedElement])? ':' (array?='ARRAY' (('[' ranges+=(STExpression) (','
	//    ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')? (type=[libraryElement::LibraryElement]) ('[' maxLength=STExpression ']')? (':='
	//    defaultValue=InitializerExpression)? ';';
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//InitializerExpression:
	//    STExpression | ArrayInitializerExpression;
	public InitializerExpressionElements getInitializerExpressionAccess() {
		return pInitializerExpression;
	}
	
	public ParserRule getInitializerExpressionRule() {
		return getInitializerExpressionAccess().getRule();
	}
	
	//ArrayInitializerExpression:
	//    '[' values+=ArrayInitElement (',' values+=ArrayInitElement)* ']';
	public ArrayInitializerExpressionElements getArrayInitializerExpressionAccess() {
		return pArrayInitializerExpression;
	}
	
	public ParserRule getArrayInitializerExpressionRule() {
		return getArrayInitializerExpressionAccess().getRule();
	}
	
	//ArrayInitElement:
	//    indexOrInitExpression=STExpression ('(' initExpression=STExpression ')')?;
	public ArrayInitElementElements getArrayInitElementAccess() {
		return pArrayInitElement;
	}
	
	public ParserRule getArrayInitElementRule() {
		return getArrayInitElementAccess().getRule();
	}
	
	//STStatement:
	//    (STIfStatement |
	//    STCaseStatement |
	//    STForStatement |
	//    STWhileStatement |
	//    STRepeatStatement |
	//    STAssignmentStatement |
	//    {STReturn} 'RETURN' |
	//    {STContinue} 'CONTINUE' |
	//    {STExit} 'EXIT') ';' |
	//    {STNop} ';';
	public STStatementElements getSTStatementAccess() {
		return pSTStatement;
	}
	
	public ParserRule getSTStatementRule() {
		return getSTStatementAccess().getRule();
	}
	
	//STAssignmentStatement:
	//    left=STAccessExpression ':=' right=STExpression
	//;
	public STAssignmentStatementElements getSTAssignmentStatementAccess() {
		return pSTAssignmentStatement;
	}
	
	public ParserRule getSTAssignmentStatementRule() {
		return getSTAssignmentStatementAccess().getRule();
	}
	
	//STIfStatement:
	//    'IF' condition=STExpression 'THEN' statements+=STStatement* elseifs+=(STElseIfPart)* (else=STElsePart)? 'END_IF';
	public STIfStatementElements getSTIfStatementAccess() {
		return pSTIfStatement;
	}
	
	public ParserRule getSTIfStatementRule() {
		return getSTIfStatementAccess().getRule();
	}
	
	//STElseIfPart:
	//    'ELSIF' condition=STExpression 'THEN' statements+=STStatement*;
	public STElseIfPartElements getSTElseIfPartAccess() {
		return pSTElseIfPart;
	}
	
	public ParserRule getSTElseIfPartRule() {
		return getSTElseIfPartAccess().getRule();
	}
	
	//STCaseStatement:
	//    'CASE' selector=STExpression 'OF' cases+=STCaseCases+ (else=STElsePart)? 'END_CASE';
	public STCaseStatementElements getSTCaseStatementAccess() {
		return pSTCaseStatement;
	}
	
	public ParserRule getSTCaseStatementRule() {
		return getSTCaseStatementAccess().getRule();
	}
	
	//STCaseCases:
	//    conditions+=STExpression (',' conditions+=STExpression)* ':'=> statements+=STStatement*;
	public STCaseCasesElements getSTCaseCasesAccess() {
		return pSTCaseCases;
	}
	
	public ParserRule getSTCaseCasesRule() {
		return getSTCaseCasesAccess().getRule();
	}
	
	//STElsePart:
	//    {STElsePart} 'ELSE' statements+=STStatement*;
	public STElsePartElements getSTElsePartAccess() {
		return pSTElsePart;
	}
	
	public ParserRule getSTElsePartRule() {
		return getSTElsePartAccess().getRule();
	}
	
	//STForStatement:
	//    'FOR' variable=[STVarDeclaration] ':=' from=STExpression 'TO' to=STExpression ('BY' by=STExpression)? 'DO'
	//    statements+=STStatement*
	//    'END_FOR';
	public STForStatementElements getSTForStatementAccess() {
		return pSTForStatement;
	}
	
	public ParserRule getSTForStatementRule() {
		return getSTForStatementAccess().getRule();
	}
	
	//STWhileStatement:
	//    'WHILE' condition=STExpression 'DO'
	//    statements+=STStatement*
	//    'END_WHILE';
	public STWhileStatementElements getSTWhileStatementAccess() {
		return pSTWhileStatement;
	}
	
	public ParserRule getSTWhileStatementRule() {
		return getSTWhileStatementAccess().getRule();
	}
	
	//STRepeatStatement:
	//    'REPEAT'
	//    statements+=STStatement*
	//    'UNTIL' condition=STExpression
	//    'END_REPEAT';
	public STRepeatStatementElements getSTRepeatStatementAccess() {
		return pSTRepeatStatement;
	}
	
	public ParserRule getSTRepeatStatementRule() {
		return getSTRepeatStatementAccess().getRule();
	}
	
	//STExpression returns STExpression:
	//    STSubrangeExpression;
	public STExpressionElements getSTExpressionAccess() {
		return pSTExpression;
	}
	
	public ParserRule getSTExpressionRule() {
		return getSTExpressionAccess().getRule();
	}
	
	//enum SubrangeOperator returns BinaryOperator: Range='..';
	public SubrangeOperatorElements getSubrangeOperatorAccess() {
		return eSubrangeOperator;
	}
	
	public EnumRule getSubrangeOperatorRule() {
		return getSubrangeOperatorAccess().getRule();
	}
	
	//STSubrangeExpression returns STExpression:
	//    STOrExpression (({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*;
	public STSubrangeExpressionElements getSTSubrangeExpressionAccess() {
		return pSTSubrangeExpression;
	}
	
	public ParserRule getSTSubrangeExpressionRule() {
		return getSTSubrangeExpressionAccess().getRule();
	}
	
	//enum OrOperator returns BinaryOperator: OR;
	public OrOperatorElements getOrOperatorAccess() {
		return eOrOperator;
	}
	
	public EnumRule getOrOperatorRule() {
		return getOrOperatorAccess().getRule();
	}
	
	//STOrExpression returns STExpression:
	//    STXorExpression (({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*;
	public STOrExpressionElements getSTOrExpressionAccess() {
		return pSTOrExpression;
	}
	
	public ParserRule getSTOrExpressionRule() {
		return getSTOrExpressionAccess().getRule();
	}
	
	//enum XorOperator returns BinaryOperator: XOR;
	public XorOperatorElements getXorOperatorAccess() {
		return eXorOperator;
	}
	
	public EnumRule getXorOperatorRule() {
		return getXorOperatorAccess().getRule();
	}
	
	//STXorExpression returns STExpression:
	//    STAndExpression (({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*;
	public STXorExpressionElements getSTXorExpressionAccess() {
		return pSTXorExpression;
	}
	
	public ParserRule getSTXorExpressionRule() {
		return getSTXorExpressionAccess().getRule();
	}
	
	//enum AndOperator returns BinaryOperator: AND | AMPERSAND='&';
	public AndOperatorElements getAndOperatorAccess() {
		return eAndOperator;
	}
	
	public EnumRule getAndOperatorRule() {
		return getAndOperatorAccess().getRule();
	}
	
	//STAndExpression returns STExpression:
	//    STEqualityExpression (({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*;
	public STAndExpressionElements getSTAndExpressionAccess() {
		return pSTAndExpression;
	}
	
	public ParserRule getSTAndExpressionRule() {
		return getSTAndExpressionAccess().getRule();
	}
	
	//enum EqualityOperator returns BinaryOperator: EQ='=' | NE='<>';
	public EqualityOperatorElements getEqualityOperatorAccess() {
		return eEqualityOperator;
	}
	
	public EnumRule getEqualityOperatorRule() {
		return getEqualityOperatorAccess().getRule();
	}
	
	//STEqualityExpression returns STExpression:
	//    STComparisonExpression (({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*;
	public STEqualityExpressionElements getSTEqualityExpressionAccess() {
		return pSTEqualityExpression;
	}
	
	public ParserRule getSTEqualityExpressionRule() {
		return getSTEqualityExpressionAccess().getRule();
	}
	
	//enum CompareOperator returns BinaryOperator: LT='<' | LE='<=' | GT='>' | GE='>=';
	public CompareOperatorElements getCompareOperatorAccess() {
		return eCompareOperator;
	}
	
	public EnumRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}
	
	//STComparisonExpression returns STExpression:
	//    STAddSubExpression (({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*;
	public STComparisonExpressionElements getSTComparisonExpressionAccess() {
		return pSTComparisonExpression;
	}
	
	public ParserRule getSTComparisonExpressionRule() {
		return getSTComparisonExpressionAccess().getRule();
	}
	
	//enum AddSubOperator returns BinaryOperator: ADD='+' | SUB='-';
	public AddSubOperatorElements getAddSubOperatorAccess() {
		return eAddSubOperator;
	}
	
	public EnumRule getAddSubOperatorRule() {
		return getAddSubOperatorAccess().getRule();
	}
	
	//STAddSubExpression returns STExpression:
	//    STMulDivModExpression (({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*;
	public STAddSubExpressionElements getSTAddSubExpressionAccess() {
		return pSTAddSubExpression;
	}
	
	public ParserRule getSTAddSubExpressionRule() {
		return getSTAddSubExpressionAccess().getRule();
	}
	
	//enum MulDivModOperator returns BinaryOperator: MUL='*' | DIV='/' | MOD;
	public MulDivModOperatorElements getMulDivModOperatorAccess() {
		return eMulDivModOperator;
	}
	
	public EnumRule getMulDivModOperatorRule() {
		return getMulDivModOperatorAccess().getRule();
	}
	
	//STMulDivModExpression returns STExpression:
	//    STPowerExpression (({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*;
	public STMulDivModExpressionElements getSTMulDivModExpressionAccess() {
		return pSTMulDivModExpression;
	}
	
	public ParserRule getSTMulDivModExpressionRule() {
		return getSTMulDivModExpressionAccess().getRule();
	}
	
	//enum PowerOperator returns BinaryOperator: POWER='**';
	public PowerOperatorElements getPowerOperatorAccess() {
		return ePowerOperator;
	}
	
	public EnumRule getPowerOperatorRule() {
		return getPowerOperatorAccess().getRule();
	}
	
	//STPowerExpression returns STExpression:
	//    STUnaryExpression (({STBinaryExpression.left=current} op=PowerOperator) right=STUnaryExpression)*;
	public STPowerExpressionElements getSTPowerExpressionAccess() {
		return pSTPowerExpression;
	}
	
	public ParserRule getSTPowerExpressionRule() {
		return getSTPowerExpressionAccess().getRule();
	}
	
	//enum UnaryOperator returns UnaryOperator: MINUS='-' | PLUS='+' | NOT;
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return eUnaryOperator;
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//STUnaryExpression returns STExpression:
	//    => STAccessExpression | ({STUnaryExpression} op=UnaryOperator expression=STUnaryExpression);
	public STUnaryExpressionElements getSTUnaryExpressionAccess() {
		return pSTUnaryExpression;
	}
	
	public ParserRule getSTUnaryExpressionRule() {
		return getSTUnaryExpressionAccess().getRule();
	}
	
	//STAccessExpression returns STExpression:
	//    STPrimaryExpression (({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
	//    STMultibitPartialExpression)) |
	//    ({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']'))*;
	public STAccessExpressionElements getSTAccessExpressionAccess() {
		return pSTAccessExpression;
	}
	
	public ParserRule getSTAccessExpressionRule() {
		return getSTAccessExpressionAccess().getRule();
	}
	
	//STPrimaryExpression returns STExpression:
	//    '(' STExpression ')' | STFeatureExpression | STLiteralExpressions;
	public STPrimaryExpressionElements getSTPrimaryExpressionAccess() {
		return pSTPrimaryExpression;
	}
	
	public ParserRule getSTPrimaryExpressionRule() {
		return getSTPrimaryExpressionAccess().getRule();
	}
	
	//STFeatureExpression returns STExpression:
	//    {STFeatureExpression} feature=[libraryElement::INamedElement] ( => '(' (parameters+=STExpression (',' parameters+=STExpression)* )? ')' )?;
	public STFeatureExpressionElements getSTFeatureExpressionAccess() {
		return pSTFeatureExpression;
	}
	
	public ParserRule getSTFeatureExpressionRule() {
		return getSTFeatureExpressionAccess().getRule();
	}
	
	//enum STMultiBitAccessSpecifier:
	//    L='%L' | D='%D' | W='%W' | B='%B' | X='%X';
	public STMultiBitAccessSpecifierElements getSTMultiBitAccessSpecifierAccess() {
		return eSTMultiBitAccessSpecifier;
	}
	
	public EnumRule getSTMultiBitAccessSpecifierRule() {
		return getSTMultiBitAccessSpecifierAccess().getRule();
	}
	
	//STMultibitPartialExpression returns STExpression:
	//    {STMultibitPartialExpression} (specifier=STMultiBitAccessSpecifier)? index=INT;
	public STMultibitPartialExpressionElements getSTMultibitPartialExpressionAccess() {
		return pSTMultibitPartialExpression;
	}
	
	public ParserRule getSTMultibitPartialExpressionRule() {
		return getSTMultibitPartialExpressionAccess().getRule();
	}
	
	//STLiteralExpressions returns STExpression:
	//    STNumericLiteral |
	//    STDateLiteral |
	//    STTimeLiteral |
	//    STTimeOfDayLiteral |
	//    STDateAndTimeLiteral |
	//    STStringLiteral;
	public STLiteralExpressionsElements getSTLiteralExpressionsAccess() {
		return pSTLiteralExpressions;
	}
	
	public ParserRule getSTLiteralExpressionsRule() {
		return getSTLiteralExpressionsAccess().getRule();
	}
	
	//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
	//STNumericLiteralType returns datatype::DataType:
	//    'BOOL#' |
	//    'BYTE#' |
	//    'WORD#' |
	//    'DWORD#' |
	//    'LWORD#' |
	//    'SINT#' |
	//    'INT#' |
	//    'DINT#' |
	//    'LINT#' |
	//    'USINT#' |
	//    'UINT#' |
	//    'UDINT#' |
	//    'ULINT#' |
	//    'REAL#' |
	//    'LREAL#'
	//;
	public STNumericLiteralTypeElements getSTNumericLiteralTypeAccess() {
		return pSTNumericLiteralType;
	}
	
	public ParserRule getSTNumericLiteralTypeRule() {
		return getSTNumericLiteralTypeAccess().getRule();
	}
	
	//STNumericLiteral:
	//    (type=STNumericLiteralType)?
	//    value=(BoolLiteral | Number | NON_DECIMAL);
	public STNumericLiteralElements getSTNumericLiteralAccess() {
		return pSTNumericLiteral;
	}
	
	public ParserRule getSTNumericLiteralRule() {
		return getSTNumericLiteralAccess().getRule();
	}
	
	//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
	//STDateLiteralType returns datatype::DataType:
	//    'DATE#' |
	//    'LDATE#' |
	//    'D#' |
	//    'LD#'
	//;
	public STDateLiteralTypeElements getSTDateLiteralTypeAccess() {
		return pSTDateLiteralType;
	}
	
	public ParserRule getSTDateLiteralTypeRule() {
		return getSTDateLiteralTypeAccess().getRule();
	}
	
	//STDateLiteral:
	//    type=STDateLiteralType value=Date;
	public STDateLiteralElements getSTDateLiteralAccess() {
		return pSTDateLiteral;
	}
	
	public ParserRule getSTDateLiteralRule() {
		return getSTDateLiteralAccess().getRule();
	}
	
	//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
	//STTimeLiteralType returns datatype::DataType:
	//    'TIME#' |
	//    'LTIME#' |
	//    'T#' |
	//    'LT#'
	//;
	public STTimeLiteralTypeElements getSTTimeLiteralTypeAccess() {
		return pSTTimeLiteralType;
	}
	
	public ParserRule getSTTimeLiteralTypeRule() {
		return getSTTimeLiteralTypeAccess().getRule();
	}
	
	//STTimeLiteral:
	//    type=STTimeLiteralType value=Time;
	public STTimeLiteralElements getSTTimeLiteralAccess() {
		return pSTTimeLiteral;
	}
	
	public ParserRule getSTTimeLiteralRule() {
		return getSTTimeLiteralAccess().getRule();
	}
	
	//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
	//STTimeOfDayLiteralType returns datatype::DataType:
	//    'TIME_OF_DAY#' |
	//    'TOD#' |
	//    'LTOD#'
	//;
	public STTimeOfDayLiteralTypeElements getSTTimeOfDayLiteralTypeAccess() {
		return pSTTimeOfDayLiteralType;
	}
	
	public ParserRule getSTTimeOfDayLiteralTypeRule() {
		return getSTTimeOfDayLiteralTypeAccess().getRule();
	}
	
	//STTimeOfDayLiteral:
	//    type=STTimeOfDayLiteralType value=TimeOfDay;
	public STTimeOfDayLiteralElements getSTTimeOfDayLiteralAccess() {
		return pSTTimeOfDayLiteral;
	}
	
	public ParserRule getSTTimeOfDayLiteralRule() {
		return getSTTimeOfDayLiteralAccess().getRule();
	}
	
	//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
	//STDateAndTimeLiteralType returns datatype::DataType:
	//    'DATE_AND_TIME#' |
	//    'LDATE_AND_TIME#' |
	//    'DT#' |
	//    'LDT#'
	//;
	public STDateAndTimeLiteralTypeElements getSTDateAndTimeLiteralTypeAccess() {
		return pSTDateAndTimeLiteralType;
	}
	
	public ParserRule getSTDateAndTimeLiteralTypeRule() {
		return getSTDateAndTimeLiteralTypeAccess().getRule();
	}
	
	//STDateAndTimeLiteral:
	//    type=STDateAndTimeLiteralType dateValue=Date '-' timeOfDayValue=TimeOfDay;
	public STDateAndTimeLiteralElements getSTDateAndTimeLiteralAccess() {
		return pSTDateAndTimeLiteral;
	}
	
	public ParserRule getSTDateAndTimeLiteralRule() {
		return getSTDateAndTimeLiteralAccess().getRule();
	}
	
	//// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
	//STStringLiteralType returns datatype::DataType:
	//    'STRING#' |
	//    'WSTRING#' |
	//    'CHAR#' |
	//    'WCHAR#'
	//;
	public STStringLiteralTypeElements getSTStringLiteralTypeAccess() {
		return pSTStringLiteralType;
	}
	
	public ParserRule getSTStringLiteralTypeRule() {
		return getSTStringLiteralTypeAccess().getRule();
	}
	
	//STStringLiteral:
	//    (type=STStringLiteralType)? value=(STRING|WSTRING);
	public STStringLiteralElements getSTStringLiteralAccess() {
		return pSTStringLiteral;
	}
	
	public ParserRule getSTStringLiteralRule() {
		return getSTStringLiteralAccess().getRule();
	}
	
	//QualifiedName:
	//    ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//// BOOLs are internally always stored as numerical value. 0 = FALSE, 1 = TRUE
	//BoolLiteral returns ecore::EBigDecimal:
	//    'TRUE' | 'FALSE'
	//;
	public BoolLiteralElements getBoolLiteralAccess() {
		return pBoolLiteral;
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}
	
	//Number returns ecore::EBigDecimal:
	//    ('+' | '-')? INT (=> '.' (EXT_INT | INT))?;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//Date returns ecore::EDate:
	//    INT '-' INT '-' INT;
	public DateElements getDateAccess() {
		return pDate;
	}
	
	public ParserRule getDateRule() {
		return getDateAccess().getRule();
	}
	
	//TimeOfDay:
	//    INT ':' INT ':' INT (=> '.' INT)?;
	public TimeOfDayElements getTimeOfDayAccess() {
		return pTimeOfDay;
	}
	
	public ParserRule getTimeOfDayRule() {
		return getTimeOfDayAccess().getRule();
	}
	
	//Time:
	//    (Number ('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS') ('_')?)+;
	public TimeElements getTimeAccess() {
		return pTime;
	}
	
	public ParserRule getTimeRule() {
		return getTimeAccess().getRule();
	}
	
	//terminal fragment HEX_DIGIT:
	//    '0'..'9' | 'a'..'f' | 'A'..'F' | '_';
	public TerminalRule getHEX_DIGITRule() {
		return tHEX_DIGIT;
	}
	
	//terminal NON_DECIMAL returns ecore::EBigDecimal:
	//    ('2#' | '8#' | '16#') HEX_DIGIT+;
	public TerminalRule getNON_DECIMALRule() {
		return tNON_DECIMAL;
	}
	
	//terminal EXT_INT:
	//    INT ('e' | 'E') ('-' | '+')? INT;
	public TerminalRule getEXT_INTRule() {
		return tEXT_INT;
	}
	
	//terminal INT returns ecore::EBigInteger:
	//    ('0'..'9') ('_'? '0'..'9')*;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal ID:
	//    '^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal STRING returns ecore::EString:
	//    '"' ('$' . /* 'L'|'N'|'P'|'R'|'T'|'"'|'$' */ | !('$' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal WSTRING returns ecore::EString:
	//    "'" ('$' . /* "L"|"N"|"P"|"R"|"T"|"'"|"$" */ | !('$' | "'"))* "'";
	public TerminalRule getWSTRINGRule() {
		return tWSTRING;
	}
	
	//terminal ML_COMMENT:
	//    '/*'->'*/' | '(*'->'*)';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//    '//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//    (' ' | '\t' | '\r' | '\n')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//    .;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
