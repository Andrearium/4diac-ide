/*******************************************************************************
 * Copyright (c) 2021 Primetals Technologies GmbH, 
 *               2022 Martin Erich Jobst
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Martin Melik Merkumians
 *       - initial API and implementation and/or initial documentation
 *   Martin Jobst
 *       - access expressions and assignment lvalues
 *       - literal data types
 *       - enhanced partial access
 *******************************************************************************/
grammar org.eclipse.fordiac.ide.structuredtextcore.STCore hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/fordiac/ide/structuredtextcore/STCore"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "org.eclipse.fordiac.ide.model.datatype" as datatype
import "org.eclipse.fordiac.ide.model.libraryElement" as libraryElement

STCoreSource returns STSource:
	{STCoreSource} statements+=STStatement*;

STVarDeclarationBlock returns STVarDeclarationBlock:
	{STVarDeclarationBlock} 'VAR' (constant?='CONSTANT')?
	varDeclarations+=STVarDeclaration*
	'END_VAR';

STVarTempDeclarationBlock returns STVarDeclarationBlock:
	{STVarDeclarationBlock} 'VAR_TEMP' (constant?='CONSTANT')?
	varDeclarations+=STVarDeclaration*
	'END_VAR';

STVarInputDeclarationBlock returns STVarDeclarationBlock:
	{STVarDeclarationBlock} 'VAR_INPUT' (constant?='CONSTANT')?
	varDeclarations+=STVarDeclaration*
	'END_VAR';

STVarOutputDeclarationBlock returns STVarDeclarationBlock:
	{STVarDeclarationBlock} 'VAR_OUTPUT' (constant?='CONSTANT')?
	varDeclarations+=STVarDeclaration*
	'END_VAR';

STVarDeclaration:
	{STVarDeclaration}
	name=ID ('AT' locatedAt=[libraryElement::INamedElement])? ':' (array?='ARRAY' (('[' ranges+=(STExpression) (','
	ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')? (type=[libraryElement::INamedElement|STAnyType]) ('[' maxLength=STExpression ']')? (':='
	defaultValue=STInitializerExpression)? ';';
	
STInitializerExpression:
	STElementaryInitializerExpression | STArrayInitializerExpression;

STElementaryInitializerExpression:
	value=STExpression;

STArrayInitializerExpression:
	'[' values+=STArrayInitElement (',' values+=STArrayInitElement)* ']';

STArrayInitElement:
	indexOrInitExpression=STExpression ('(' initExpressions+=STExpression (',' initExpressions+=STExpression)* ')')?;
	
STStatement:
	(STIfStatement |
	STCaseStatement |
	STForStatement |
	STWhileStatement |
	STRepeatStatement |
	=> STAssignmentStatement |
	STCallStatement |
	{STReturn} 'RETURN' |
	{STContinue} 'CONTINUE' |
	{STExit} 'EXIT') ';' |
	{STNop} ';';

STAssignmentStatement:
	left=STAccessExpression ':=' right=STExpression
;

STCallStatement:
	call=STAccessExpression
;

STCallArgument:
	STCallUnnamedArgument | STCallNamedInputArgument | STCallNamedOutputArgument
;

STCallUnnamedArgument:
	arg=STExpression
;

STCallNamedInputArgument:
	target=[libraryElement::INamedElement] ':=' source=STExpression 
;

STCallNamedOutputArgument:
	not?='NOT'? source=[libraryElement::INamedElement] '=>' target=[libraryElement::INamedElement] 
;

STIfStatement:
	'IF' condition=STExpression 'THEN' statements+=STStatement* elseifs+=(STElseIfPart)* (else=STElsePart)? 'END_IF';

STElseIfPart:
	'ELSIF' condition=STExpression 'THEN' statements+=STStatement*;

STCaseStatement:
	'CASE' selector=STExpression 'OF' cases+=STCaseCases+ (else=STElsePart)? 'END_CASE';

STCaseCases:
	conditions+=STExpression (',' conditions+=STExpression)* ':'=> statements+=STStatement*;

STElsePart:
	{STElsePart} 'ELSE' statements+=STStatement*;

STForStatement:
	'FOR' variable=[STVarDeclaration] ':=' from=STExpression 'TO' to=STExpression ('BY' by=STExpression)? 'DO'
	statements+=STStatement*
	'END_FOR';

STWhileStatement:
	'WHILE' condition=STExpression 'DO'
	statements+=STStatement*
	'END_WHILE';

STRepeatStatement:
	'REPEAT'
	statements+=STStatement*
	'UNTIL' condition=STExpression
	'END_REPEAT';

STExpression returns STExpression:
	STSubrangeExpression;

enum SubrangeOperator returns STBinaryOperator: Range='..';
STSubrangeExpression returns STExpression:
	STOrExpression (({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*;

enum OrOperator returns STBinaryOperator: OR;
STOrExpression returns STExpression:
	STXorExpression (({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*;

enum XorOperator returns STBinaryOperator: XOR;
STXorExpression returns STExpression:
	STAndExpression (({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*;

enum AndOperator returns STBinaryOperator: AND | AMPERSAND='&';
STAndExpression returns STExpression:
	STEqualityExpression (({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*;

enum EqualityOperator returns STBinaryOperator: EQ='=' | NE='<>';
STEqualityExpression returns STExpression:
	STComparisonExpression (({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*;

enum CompareOperator returns STBinaryOperator: LT='<' | LE='<=' | GT='>' | GE='>=';
STComparisonExpression returns STExpression:
	STAddSubExpression (({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*;

enum AddSubOperator returns STBinaryOperator: ADD='+' | SUB='-';
STAddSubExpression returns STExpression:
	STMulDivModExpression (({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*;

enum MulDivModOperator returns STBinaryOperator: MUL='*' | DIV='/' | MOD;
STMulDivModExpression returns STExpression:
	STPowerExpression (({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*;

enum PowerOperator returns STBinaryOperator: POWER='**';
STPowerExpression returns STExpression:
	STUnaryExpression (({STBinaryExpression.left=current} op=PowerOperator) right=STUnaryExpression)*;

enum UnaryOperator returns STUnaryOperator: MINUS='-' | PLUS='+' | NOT;
STUnaryExpression returns STExpression:
	=> STAccessExpression | ({STUnaryExpression} op=UnaryOperator expression=STUnaryExpression);

STAccessExpression returns STExpression:
	STPrimaryExpression (({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
	STMultibitPartialExpression)) |
	({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']'))*;

STPrimaryExpression returns STExpression:
	'(' STExpression ')' | STFeatureExpression | STLiteralExpressions;

STFeatureExpression returns STExpression:
	{STFeatureExpression} feature=[libraryElement::INamedElement] ( => '(' (parameters+=STCallArgument (',' parameters+=STCallArgument)* )? ')' )?;

enum STMultiBitAccessSpecifier:
	L='%L' | D='%D' | W='%W' | B='%B' | X='%X';

STMultibitPartialExpression returns STExpression:
	{STMultibitPartialExpression} (specifier=STMultiBitAccessSpecifier)? (index=INT | ('(' expression=STExpression ')'));

STLiteralExpressions returns STExpression:
	STNumericLiteral |
	STDateLiteral |
	STTimeLiteral |
	STTimeOfDayLiteral |
	STDateAndTimeLiteral |
	STStringLiteral;

STNumericLiteralType:
	STAnyBitType | STAnyNumType;

STNumericLiteral:
	(type=[datatype::DataType|STNumericLiteralType] '#')?
	value=(BoolLiteral | Number | NON_DECIMAL);

STDateLiteralType:
	STDateType |
	'D' |
	'LD'
;

STDateLiteral:
	type=[datatype::DataType|STDateLiteralType] '#' value=Date;

STTimeLiteralType:
	STAnyDurationType |
	'T' |
	'LT'
;

STTimeLiteral:
	type=[datatype::DataType|STTimeLiteralType] '#' value=Time;

STTimeOfDayLiteral:
	type=[datatype::DataType|STTimeOfDayType] '#' value=TimeOfDay;

STDateAndTimeLiteral:
	type=[datatype::DataType|STDateAndTimeType] '#' value=DateAndTime;

STStringLiteral:
	(type=[datatype::DataType|STAnyCharsType] '#')? value=(STRING|WSTRING);

STAnyType:
	ID | STAnyBuiltinType;

STAnyBuiltinType:
	STAnyBitType | STAnyNumType | STAnyDurationType | STAnyDateType | STAnyCharsType;

STAnyBitType:
	'BOOL' | 'BYTE' | 'WORD' | 'DWORD' | 'LWORD';

STAnyNumType:
	'SINT' | 'INT' | 'DINT' | 'LINT' | 'USINT' | 'UINT' | 'UDINT' | 'ULINT' | 'REAL' | 'LREAL';

STAnyDurationType:
	'TIME' | 'LTIME';

STAnyDateType:
	STDateType | STTimeOfDayType | STDateAndTimeType;

STDateType:
	'DATE' | 'LDATE';

STTimeOfDayType:
	'TIME_OF_DAY' |
	'LTIME_OF_DAY' |
	'TOD' |
	'LTOD'
;

STDateAndTimeType:
	'DATE_AND_TIME' |
	'LDATE_AND_TIME' |
	'DT' |
	'LDT'
;

STAnyCharsType:
	'STRING' | 'WSTRING' | 'CHAR' | 'WCHAR';

QualifiedName:
	ID ('.' ID)*;

// BOOLs are internally always stored as numerical value. 0 = FALSE, 1 = TRUE
BoolLiteral returns ecore::EBigDecimal:
	'TRUE' | 'FALSE'
;

Number returns ecore::EBigDecimal:
	('+' | '-')? INT (=> '.' (EXT_INT | INT))?;

Date returns STDate:
	INT '-' INT '-' INT;

DateAndTime returns STDateAndTime:
	INT '-' INT '-' INT '-' INT ':' INT ':' INT (=> '.' INT)?;

TimeOfDay returns STTimeOfDay:
	INT ':' INT ':' INT (=> '.' INT)?;

Time returns STTime:
	(Number ('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS') ('_')?)+;

terminal fragment HEX_DIGIT:
	'0'..'9' | 'a'..'f' | 'A'..'F' | '_';

terminal NON_DECIMAL returns ecore::EBigDecimal:
	('2#' | '8#' | '16#') HEX_DIGIT+;

terminal EXT_INT:
	INT ('e' | 'E') ('-' | '+')? INT;

terminal INT returns ecore::EBigInteger:
	('0'..'9') ('_'? '0'..'9')*;

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal STRING returns ecore::EString:
	"'" ('$' . /* "L"|"N"|"P"|"R"|"T"|"'"|"$" */ | !('$' | "'"))* "'";

terminal WSTRING returns ecore::EString:
	'"' ('$' . /* 'L'|'N'|'P'|'R'|'T'|'"'|'$' */ | !('$' | '"'))* '"';

terminal ML_COMMENT:
	'/*'->'*/' | '(*'->'*)';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;