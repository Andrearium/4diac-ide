/*******************************************************************************
 * Copyright (c) 2021 Primetals Technologies GmbH, 
 *               2022 Martin Erich Jobst
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Martin Melik Merkumians
 *       - initial API and implementation and/or initial documentation
 *   Martin Jobst
 *       - access expressions and assignment lvalues
 *******************************************************************************/
grammar org.eclipse.fordiac.ide.structuredtextcore.STCore hidden(WS, ML_COMMENT, SL_COMMENT)

generate sTCore "http://www.eclipse.org/fordiac/ide/structuredtextcore/STCore"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "org.eclipse.fordiac.ide.model.datatype" as datatype
import "org.eclipse.fordiac.ide.model.libraryElement" as libraryElement

Code:
	statements+=STStatement*;

VarDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarTempDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR_TEMP' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarInputDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR_INPUT' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarOutputDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR_OUTPUT' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarDeclaration returns libraryElement::INamedElement:
	{STVarDeclaration}
	name=ID ('AT' locatedAt=[libraryElement::INamedElement])? ':' (array?='ARRAY' (('[' ranges+=(STExpression) (','
	ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')? (type=[libraryElement::LibraryElement]) ('[' maxLength=STExpression ']')? (':='
	defaultValue=InitializerExpression)? ';';
	
InitializerExpression:
	STExpression | ArrayInitializerExpression;

ArrayInitializerExpression:
	'[' values+=ArrayInitElement (',' values+=ArrayInitElement)* ']';

ArrayInitElement:
	indexOrInitExpression=STExpression ('(' initExpression=STExpression ')')?;
	
STStatement:
	(STIfStatement |
	STCaseStatement |
	STForStatement |
	STWhileStatement |
	STRepeatStatement |
	STAssignmentStatement |
	{STReturn} 'RETURN' |
	{STContinue} 'CONTINUE' |
	{STExit} 'EXIT') ';' |
	{STNop} ';';

STAssignmentStatement:
	left=STAccessExpression ':=' right=STExpression
;

STIfStatement:
	'IF' condition=STExpression 'THEN' statements+=STStatement* elseifs+=(STElseIfPart)* (else=STElsePart)? 'END_IF';

STElseIfPart:
	'ELSIF' condition=STExpression 'THEN' statements+=STStatement*;

STCaseStatement:
	'CASE' selector=STExpression 'OF' cases+=STCaseCases+ (else=STElsePart)? 'END_CASE';

STCaseCases:
	conditions+=STExpression (',' conditions+=STExpression)* ':'=> statements+=STStatement*;

STElsePart:
	{STElsePart} 'ELSE' statements+=STStatement*;

STForStatement:
	'FOR' for=STExpression 'TO' to=STExpression ('BY' by=STExpression)? 'DO'
	statements+=STStatement*
	'END_FOR';

STWhileStatement:
	'WHILE' condition=STExpression 'DO'
	statements+=STStatement*
	'END_WHILE';

STRepeatStatement:
	'REPEAT'
	statements+=STStatement*
	'UNTIL' condition=STExpression
	'END_REPEAT';

STExpression returns STExpression:
	STSubrangeExpression;

enum SubrangeOperator returns BinaryOperator: Range='..';
STSubrangeExpression returns STExpression:
	STOrExpression (({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*;

enum OrOperator returns BinaryOperator: OR;
STOrExpression returns STExpression:
	STXorExpression (({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*;

enum XorOperator returns BinaryOperator: XOR;
STXorExpression returns STExpression:
	STAndExpression (({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*;

enum AndOperator returns BinaryOperator: AND | AMPERSAND='&';
STAndExpression returns STExpression:
	STEqualityExpression (({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*;

enum EqualityOperator returns BinaryOperator: EQ='=' | NE='<>';
STEqualityExpression returns STExpression:
	STComparisonExpression (({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*;

enum CompareOperator returns BinaryOperator: LT='<' | LE='<=' | GT='>' | GE='>=';
STComparisonExpression returns STExpression:
	STAddSubExpression (({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*;

enum AddSubOperator returns BinaryOperator: ADD='+' | SUB='-';
STAddSubExpression returns STExpression:
	STMulDivModExpression (({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*;

enum MulDivModOperator returns BinaryOperator: MUL='*' | DIV='/' | MOD;
STMulDivModExpression returns STExpression:
	STPowerExpression (({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*;

enum PowerOperator returns BinaryOperator: POWER='**';
STPowerExpression returns STExpression:
	STUnaryExpression (({STBinaryExpression.left=current} op=PowerOperator) right=STUnaryExpression)*;

enum UnaryOperator returns UnaryOperator: MINUS='-' | PLUS='+' | NOT;
STUnaryExpression returns STExpression:
	=> STAccessExpression | ({STUnaryExpression} op=UnaryOperator expression=STUnaryExpression);

STAccessExpression returns STExpression:
	STPrimaryExpression (({STMemberAccessExpression.receiver=current} '.' member=(STFeatureExpression |
	STMultibitPartialExpression)) |
	({STArrayAccessExpression.receiver=current} '[' index+=STExpression (',' index+=STExpression)* ']'))*;

STPrimaryExpression returns STExpression:
	'(' STExpression ')' | STFeatureExpression | STLiteralExpressions;

STFeatureExpression returns STExpression:
	{STFeatureExpression} feature=[libraryElement::INamedElement] ( => '(' (parameters+=STExpression (',' parameters+=STExpression)* )? ')' )?;

enum STMultiBitAccessSpecifier:
	L='%L' | D='%D' | W='%W' | B='%B' | X='%X';

STMultibitPartialExpression returns STExpression:
	{STMultibitPartialExpression} (specifier=STMultiBitAccessSpecifier)? index=INT;

STLiteralExpressions returns STExpression:
	STNumericLiteral |
	STDateLiteral |
	STTimeLiteral |
	STTimeOfDayLiteral |
	STDateAndTimeLiteral |
	STStringLiteral;

// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
STNumericLiteralType returns datatype::DataType:
	'BOOL#' |
	'BYTE#' |
	'WORD#' |
	'DWORD#' |
	'LWORD#' |
	'SINT#' |
	'INT#' |
	'DINT#' |
	'LINT#' |
	'USINT#' |
    'UINT#' |
    'UDINT#' |
    'ULINT#' |
    'REAL#' |
    'LREAL#'
;
    
STNumericLiteral:
	(type=STNumericLiteralType)?
	value=(BoolLiteral | Number | NON_DECIMAL);

// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
STDateLiteralType returns datatype::DataType:
	'DATE#' |
	'LDATE#' |
	'D#' |
	'LD#'
;

STDateLiteral:
	type=STDateLiteralType value=Date;

// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
STTimeLiteralType returns datatype::DataType:
	'TIME#' |
	'LTIME#' |
	'T#' |
	'LT#'
;

STTimeLiteral:
	type=STTimeLiteralType value=Time;

// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
STTimeOfDayLiteralType returns datatype::DataType:
	'TIME_OF_DAY#' |
	'TOD#' |
	'LTOD#'
;

STTimeOfDayLiteral:
	type=STTimeOfDayLiteralType value=TimeOfDay;

// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
STDateAndTimeLiteralType returns datatype::DataType:
	'DATE_AND_TIME#' |
	'LDATE_AND_TIME#' |
	'DT#' |
	'LDT#'
;
STDateAndTimeLiteral:
	type=STDateAndTimeLiteralType dateValue=Date '-' timeOfDayValue=TimeOfDay;

// DataType is abstract, so no object creation! ValueConverter will provide the concrete type
STStringLiteralType returns datatype::DataType:
	'STRING#' |
	'WSTRING#' |
	'CHAR#' |
	'WCHAR#'
;

STStringLiteral:
	(type=STStringLiteralType)? value=(STRING|WSTRING);

QualifiedName:
	ID ('.' ID)*;

// BOOLs are internally always stored as numerical value. 0 = FALSE, 1 = TRUE
BoolLiteral returns ecore::EBigDecimal:
	'TRUE' | 'FALSE'
;

Number returns ecore::EBigDecimal:
	('+' | '-')? INT (=> '.' (EXT_INT | INT))?;

Date returns ecore::EDate:
	INT '-' INT '-' INT;

TimeOfDay:
	INT ':' INT ':' INT (=> '.' INT)?;

Time:
	(Number ('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS') ('_')?)+;

terminal fragment HEX_DIGIT:
	'0'..'9' | 'a'..'f' | 'A'..'F' | '_';

terminal NON_DECIMAL returns ecore::EBigDecimal:
	('2#' | '8#' | '16#') HEX_DIGIT+;

terminal EXT_INT:
	INT ('e' | 'E') ('-' | '+')? INT;

terminal INT returns ecore::EBigInteger:
	('0'..'9') ('_'? '0'..'9')*;

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal STRING returns ecore::EString:
	'"' ('$' . /* 'L'|'N'|'P'|'R'|'T'|'"'|'$' */ | !('$' | '"'))* '"';

terminal WSTRING returns ecore::EString:
	"'" ('$' . /* "L"|"N"|"P"|"R"|"T"|"'"|"$" */ | !('$' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/' | '(*'->'*)';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;