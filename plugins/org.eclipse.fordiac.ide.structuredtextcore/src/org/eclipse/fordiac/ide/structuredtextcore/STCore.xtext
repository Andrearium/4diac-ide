/*******************************************************************************
 * Copyright (c) 2021 Primetals Technologies GmbH
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Martin Melik Merkumians
 *       - initial API and implementation and/or initial documentation
 *******************************************************************************/
grammar org.eclipse.fordiac.ide.structuredtextcore.STCore hidden(WS, ML_COMMENT, SL_COMMENT)

generate sTCore "http://www.eclipse.org/fordiac/ide/structuredtextcore/STCore"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "org.eclipse.fordiac.ide.model.datatype" as datatype
import "org.eclipse.fordiac.ide.model.libraryElement" as libraryElement

Code:
	statements+=STStatement*;

VarDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarTempDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR_TEMP' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarInputDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR_INPUT' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarOutputDeclarationBlock returns VarDeclarationBlock:
	{VarDeclarationBlock} 'VAR_OUTPUT' (constant?='CONSTANT')?
	varDeclarations+=VarDeclaration*
	'END_VAR';

VarDeclaration returns VarDeclaration:
	name=ID ('AT' locatedAt=[VarDeclaration])? ':' (array?='ARRAY' (('[' ranges+=(STExpression) (','
	ranges+=STExpression)* ']') | ('[' count+='*' (',' count+='*')* ']')) 'OF')? (type=[libraryElement::LibraryElement]) ('[' maxLength=STExpression ']')? (':='
	defaultValue=InitializerExpression)? ';';
	
InitializerExpression:
	STExpression | ArrayInitializerExpression;

ArrayInitializerExpression:
	'[' values+=ArrayInitElement (',' values+=ArrayInitElement)* ']';

ArrayInitElement:
	indexOrInitExpression=STExpression ('(' initExpression=STExpression ')')?;
	
STStatement:
	(STIfStatment |
	STCaseStatement |
	STForStatement |
	STWhileStatement |
	STRepeatStatement |
	STAssignmentStatement |
	{STReturn} 'RETURN' |
	{STContinue} 'CONTINUE' |
	{STExit} 'EXIT') ';' |
	{STNop} ';';

STAssignmentStatement:
	lhs=[VarDeclaration] ':=' rhs=STExpression
;

STIfStatment:
	'IF' condition=STExpression 'THEN' statements+=STStatement* elseifs+=(STElseIfPart)* (else=STElsePart)? 'END_IF';

STElseIfPart:
	'ELSIF' condition=STExpression 'THEN' statements+=STStatement*;

STCaseStatement:
	'CASE' selector=STExpression 'OF' cases+=STCaseCases+ (else=STElsePart)? 'END_CASE';

STCaseCases:
	conditions+=STExpression (',' conditions+=STExpression)* ':'=> statements+=STStatement*;

STElsePart:
	{STElsePart} 'ELSE' statements+=STStatement*;

STForStatement:
	'FOR' for=STExpression 'TO' to=STExpression ('BY' by=STExpression)? 'DO'
	statements+=STStatement*
	'END_FOR';

STWhileStatement:
	'WHILE' condition=STExpression 'DO'
	statements+=STStatement*
	'END_WHILE';

STRepeatStatement:
	'REPEAT'
	statements+=STStatement*
	'UNTIL' condition=STExpression
	'END_REPEAT';

STExpression returns STExpression:
	STSubrangeExpression;

enum SubrangeOperator returns BinaryOperator: Range='..';
STSubrangeExpression returns STExpression:
	STOrExpression (({STBinaryExpression.left=current} op=SubrangeOperator) right=STOrExpression)*;

enum OrOperator returns BinaryOperator: OR;
STOrExpression returns STExpression:
	STXorExpression (({STBinaryExpression.left=current} op=OrOperator) right=STXorExpression)*;

enum XorOperator returns BinaryOperator: XOR;
STXorExpression returns STExpression:
	STAndExpression (({STBinaryExpression.left=current} op=XorOperator) right=STAndExpression)*;

enum AndOperator returns BinaryOperator: AND | AMPERSAND='&';
STAndExpression returns STExpression:
	STEqualityExpression (({STBinaryExpression.left=current} op=AndOperator) right=STEqualityExpression)*;

enum EqualityOperator returns BinaryOperator: EQ='=' | NE='<>';
STEqualityExpression returns STExpression:
	STComparisonExpression (({STBinaryExpression.left=current} op=EqualityOperator) right=STComparisonExpression)*;

enum CompareOperator returns BinaryOperator: LT='<' | LE='<=' | GT='>' | GE='>=';
STComparisonExpression returns STExpression:
	STAddSubExpression (({STBinaryExpression.left=current} op=CompareOperator) right=STAddSubExpression)*;

enum AddSubOperator returns BinaryOperator: ADD='+' | SUB='-';
STAddSubExpression returns STExpression:
	STMulDivModExpression (({STBinaryExpression.left=current} op=AddSubOperator) right=STMulDivModExpression)*;

enum MulDivModOperator returns BinaryOperator: MUL='*' | DIV='/' | MOD;
STMulDivModExpression returns STExpression:
	STPowerExpression (({STBinaryExpression.left=current} op=MulDivModOperator) right=STPowerExpression)*;

enum PowerOperator returns BinaryOperator: POWER='**';
STPowerExpression returns STExpression:
	STSignumExpression (({STBinaryExpression.left=current} op=PowerOperator) right=STSignumExpression)*;

enum UnaryOperator returns UnaryOperator: MINUS='-' | PLUS='+' | NOT;
STSignumExpression returns STExpression:
	STLiteralExpressions | STSelectionExpression | ({STUnaryExpression} op=UnaryOperator
	expression=STSelectionExpression);

STSelectionExpression returns STExpression:
	STAtomicExpression 
	({STMemberSelection.receiver=current} (structAccess?='.' member=[VarDeclaration] | arrayAccess?='['
	index+=STExpression (',' index+=STExpression)* ']')
	(=>poeInvocation?='(' (parameters+=STExpression (',' parameters+=STExpression)*)? ')')?
	(=>bitaccessor=MultibitPartialAccess)?
	)*;

MultibitPartialAccess:
	(accessSpecifier=MultiBitAccessSpecifier) index=INT;

enum MultiBitAccessSpecifier:
	lwordAccess='.%L' | dwordAccess='.%D' | wordAccess='.%W' | byteAccess='.%B' | bitAccess='.%X' |
	bitAccessShortcut='.';

STAtomicExpression returns STExpression:
	'(' STExpression ')' |
	{STSymbol} (type=[datatype::DataType] '#')? symbol=[VarDeclaration] (bitaccessor=MultibitPartialAccess)? (=>poeInvocation?=
	'(' (parameters+=STExpression (',' parameters+=STExpression)*)? ')')? ;

STLiteralExpressions returns STExpression:
	{STBoolLiteral} boolLiteral=BOOL_LITERAL |
	{STNumericLiteral} numericLiteral=NUMERIC_LITERAL |
	{STDateLiteral} dateLiteral=DATE_LITERAL |
	{STTimeLiteral} timeLiteral=TIME_LITERAL |
	{STTimeOfDayLiteral} timeOfDayLiteral=TIME_OF_DAY_LITERAL |
	{STDateAndTimeLiteral} timeLiteral=DATE_AND_TIME_LITERAL |
	{STStringLiteral} stringLiteral=STRING_LITERAL;

BOOL_LITERAL:
	('BOOL#')? ('TRUE' | 'FALSE')
;

NUMERIC_LITERAL:
	(keyword=('BOOL#' | 'BYTE#' | 'WORD#' | 'DWORD#' | 'LWORD#' | 'SINT#' | 'INT#' | 'DINT#' | 'LINT#' | 'USINT#' |
	'UINT#' | 'UDINT#' | 'ULINT#' |	'REAL#' | 'LREAL#'))?
	(intValue=INTEGER | realValue=REAL | hexValue=NON_DECIMAL);

DATE_LITERAL:
	keyword=('DATE#' | 'LDATE#' | 'D#' | 'LD#') value=DATE;

TIME_LITERAL:
	keyword=('TIME#' | 'LTIME#' | 'T#' | 'LT#') value=TIME;

TIME_OF_DAY_LITERAL:
	keyword=('TIME_OF_DAY#' | 'TOD#' | 'LTOD#') value=TIME_OF_DAY;

DATE_AND_TIME_LITERAL:
	keyword=('DATE_AND_TIME#' | 'LDATE_AND_TIME#' | 'DT#' | 'LDT#') dateValue=DATE '-' timeOfDayValue=TIME_OF_DAY;

STRING_LITERAL:
	(keyword='STRING#' | 'WSTRING#' | 'CHAR#' | 'WCHAR#')? value=STRING;

terminal fragment HEX_DIGIT:
	'0'..'9' | 'a'..'f' | 'A'..'F' | '_';

terminal NON_DECIMAL returns ecore::EBigInteger:
	('2#' | '8#' | '16#') HEX_DIGIT+;

terminal INT returns ecore::EBigInteger:
	('0'..'9') ('_'? '0'..'9')*;

QualifiedName:
	ID ('.' ID)*;

INTEGER returns ecore::EBigInteger:
	('+' | '-')? INT;

REAL returns ecore::EBigDecimal:
	INTEGER '.' (EXT_INT | INT); // INT ? '.' (EXT_INT | INT);

DATE returns ecore::EDate:
	INT '-' INT '-' INT;

terminal TIME:
	('+' | '-')? (INT ('.' INT)? ('D' | 'H' | 'M' | 'S' | 'MS' | 'US' | 'NS') ('_')?)+;

TIME_OF_DAY:
	INT ':' INT ':' INT ('.' INT)?;

terminal EXT_INT:
	INT ('e' | 'E') ('-' | '+')? INT;

terminal ID:
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal STRING returns ecore::EString:
	'"' ('$' . /* 'L'|'N'|'P'|'R'|'T'|'"'|'$' */ | !('$' | '"'))* '"';

terminal WSTRING returns ecore::EString:
	"'" ('$' . /* "L"|"N"|"P"|"R"|"T"|"'"|"$" */ | !('$' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/' | '(*'->'*)';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;